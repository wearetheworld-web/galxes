(window.webpackJsonp=window.webpackJsonp||[]).push([[1130],{1139:function(e,t,n){"use strict";(function(e){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.CompressedNonExistenceProof=t.CompressedExistenceProof=t.CompressedBatchEntry=t.CompressedBatchProof=t.BatchEntry=t.BatchProof=t.InnerSpec=t.ProofSpec=t.InnerOp=t.LeafOp=t.CommitmentProof=t.NonExistenceProof=t.ExistenceProof=t.lengthOpToJSON=t.lengthOpFromJSON=t.LengthOp=t.hashOpToJSON=t.hashOpFromJSON=t.HashOp=t.protobufPackage=void 0;const o=r(n(33)),c=r(n(44));var d,l;function f(object){switch(object){case 0:case"NO_HASH":return d.NO_HASH;case 1:case"SHA256":return d.SHA256;case 2:case"SHA512":return d.SHA512;case 3:case"KECCAK":return d.KECCAK;case 4:case"RIPEMD160":return d.RIPEMD160;case 5:case"BITCOIN":return d.BITCOIN;default:return d.UNRECOGNIZED}}function h(object){switch(object){case d.NO_HASH:return"NO_HASH";case d.SHA256:return"SHA256";case d.SHA512:return"SHA512";case d.KECCAK:return"KECCAK";case d.RIPEMD160:return"RIPEMD160";case d.BITCOIN:return"BITCOIN";default:return"UNKNOWN"}}function v(object){switch(object){case 0:case"NO_PREFIX":return l.NO_PREFIX;case 1:case"VAR_PROTO":return l.VAR_PROTO;case 2:case"VAR_RLP":return l.VAR_RLP;case 3:case"FIXED32_BIG":return l.FIXED32_BIG;case 4:case"FIXED32_LITTLE":return l.FIXED32_LITTLE;case 5:case"FIXED64_BIG":return l.FIXED64_BIG;case 6:case"FIXED64_LITTLE":return l.FIXED64_LITTLE;case 7:case"REQUIRE_32_BYTES":return l.REQUIRE_32_BYTES;case 8:case"REQUIRE_64_BYTES":return l.REQUIRE_64_BYTES;default:return l.UNRECOGNIZED}}function m(object){switch(object){case l.NO_PREFIX:return"NO_PREFIX";case l.VAR_PROTO:return"VAR_PROTO";case l.VAR_RLP:return"VAR_RLP";case l.FIXED32_BIG:return"FIXED32_BIG";case l.FIXED32_LITTLE:return"FIXED32_LITTLE";case l.FIXED64_BIG:return"FIXED64_BIG";case l.FIXED64_LITTLE:return"FIXED64_LITTLE";case l.REQUIRE_32_BYTES:return"REQUIRE_32_BYTES";case l.REQUIRE_64_BYTES:return"REQUIRE_64_BYTES";default:return"UNKNOWN"}}t.protobufPackage="ics23",function(e){e[e.NO_HASH=0]="NO_HASH",e[e.SHA256=1]="SHA256",e[e.SHA512=2]="SHA512",e[e.KECCAK=3]="KECCAK",e[e.RIPEMD160=4]="RIPEMD160",e[e.BITCOIN=5]="BITCOIN",e[e.UNRECOGNIZED=-1]="UNRECOGNIZED"}(d=t.HashOp||(t.HashOp={})),t.hashOpFromJSON=f,t.hashOpToJSON=h,function(e){e[e.NO_PREFIX=0]="NO_PREFIX",e[e.VAR_PROTO=1]="VAR_PROTO",e[e.VAR_RLP=2]="VAR_RLP",e[e.FIXED32_BIG=3]="FIXED32_BIG",e[e.FIXED32_LITTLE=4]="FIXED32_LITTLE",e[e.FIXED64_BIG=5]="FIXED64_BIG",e[e.FIXED64_LITTLE=6]="FIXED64_LITTLE",e[e.REQUIRE_32_BYTES=7]="REQUIRE_32_BYTES",e[e.REQUIRE_64_BYTES=8]="REQUIRE_64_BYTES",e[e.UNRECOGNIZED=-1]="UNRECOGNIZED"}(l=t.LengthOp||(t.LengthOp={})),t.lengthOpFromJSON=v,t.lengthOpToJSON=m;const x={};t.ExistenceProof={encode(e,n=c.default.Writer.create()){0!==e.key.length&&n.uint32(10).bytes(e.key),0!==e.value.length&&n.uint32(18).bytes(e.value),void 0!==e.leaf&&t.LeafOp.encode(e.leaf,n.uint32(26).fork()).ldelim();for(const r of e.path)t.InnerOp.encode(r,n.uint32(34).fork()).ldelim();return n},decode(input,e){const n=input instanceof c.default.Reader?input:new c.default.Reader(input);let r=void 0===e?n.len:n.pos+e;const o=Object.assign({},x);for(o.path=[],o.key=new Uint8Array,o.value=new Uint8Array;n.pos<r;){const e=n.uint32();switch(e>>>3){case 1:o.key=n.bytes();break;case 2:o.value=n.bytes();break;case 3:o.leaf=t.LeafOp.decode(n,n.uint32());break;case 4:o.path.push(t.InnerOp.decode(n,n.uint32()));break;default:n.skipType(7&e)}}return o},fromJSON(object){var e;const n=Object.assign({},x);return n.key=void 0!==object.key&&null!==object.key?J(object.key):new Uint8Array,n.value=void 0!==object.value&&null!==object.value?J(object.value):new Uint8Array,n.leaf=void 0!==object.leaf&&null!==object.leaf?t.LeafOp.fromJSON(object.leaf):void 0,n.path=(null!==(e=object.path)&&void 0!==e?e:[]).map((e=>t.InnerOp.fromJSON(e))),n},toJSON(e){const n={};return void 0!==e.key&&(n.key=T(void 0!==e.key?e.key:new Uint8Array)),void 0!==e.value&&(n.value=T(void 0!==e.value?e.value:new Uint8Array)),void 0!==e.leaf&&(n.leaf=e.leaf?t.LeafOp.toJSON(e.leaf):void 0),e.path?n.path=e.path.map((e=>e?t.InnerOp.toJSON(e):void 0)):n.path=[],n},fromPartial(object){var e,n,r;const o=Object.assign({},x);return o.key=null!==(e=object.key)&&void 0!==e?e:new Uint8Array,o.value=null!==(n=object.value)&&void 0!==n?n:new Uint8Array,o.leaf=void 0!==object.leaf&&null!==object.leaf?t.LeafOp.fromPartial(object.leaf):void 0,o.path=(null===(r=object.path)||void 0===r?void 0:r.map((e=>t.InnerOp.fromPartial(e))))||[],o}};const O={};t.NonExistenceProof={encode:(e,n=c.default.Writer.create())=>(0!==e.key.length&&n.uint32(10).bytes(e.key),void 0!==e.left&&t.ExistenceProof.encode(e.left,n.uint32(18).fork()).ldelim(),void 0!==e.right&&t.ExistenceProof.encode(e.right,n.uint32(26).fork()).ldelim(),n),decode(input,e){const n=input instanceof c.default.Reader?input:new c.default.Reader(input);let r=void 0===e?n.len:n.pos+e;const o=Object.assign({},O);for(o.key=new Uint8Array;n.pos<r;){const e=n.uint32();switch(e>>>3){case 1:o.key=n.bytes();break;case 2:o.left=t.ExistenceProof.decode(n,n.uint32());break;case 3:o.right=t.ExistenceProof.decode(n,n.uint32());break;default:n.skipType(7&e)}}return o},fromJSON(object){const e=Object.assign({},O);return e.key=void 0!==object.key&&null!==object.key?J(object.key):new Uint8Array,e.left=void 0!==object.left&&null!==object.left?t.ExistenceProof.fromJSON(object.left):void 0,e.right=void 0!==object.right&&null!==object.right?t.ExistenceProof.fromJSON(object.right):void 0,e},toJSON(e){const n={};return void 0!==e.key&&(n.key=T(void 0!==e.key?e.key:new Uint8Array)),void 0!==e.left&&(n.left=e.left?t.ExistenceProof.toJSON(e.left):void 0),void 0!==e.right&&(n.right=e.right?t.ExistenceProof.toJSON(e.right):void 0),n},fromPartial(object){var e;const n=Object.assign({},O);return n.key=null!==(e=object.key)&&void 0!==e?e:new Uint8Array,n.left=void 0!==object.left&&null!==object.left?t.ExistenceProof.fromPartial(object.left):void 0,n.right=void 0!==object.right&&null!==object.right?t.ExistenceProof.fromPartial(object.right):void 0,n}};const y={};t.CommitmentProof={encode:(e,n=c.default.Writer.create())=>(void 0!==e.exist&&t.ExistenceProof.encode(e.exist,n.uint32(10).fork()).ldelim(),void 0!==e.nonexist&&t.NonExistenceProof.encode(e.nonexist,n.uint32(18).fork()).ldelim(),void 0!==e.batch&&t.BatchProof.encode(e.batch,n.uint32(26).fork()).ldelim(),void 0!==e.compressed&&t.CompressedBatchProof.encode(e.compressed,n.uint32(34).fork()).ldelim(),n),decode(input,e){const n=input instanceof c.default.Reader?input:new c.default.Reader(input);let r=void 0===e?n.len:n.pos+e;const o=Object.assign({},y);for(;n.pos<r;){const e=n.uint32();switch(e>>>3){case 1:o.exist=t.ExistenceProof.decode(n,n.uint32());break;case 2:o.nonexist=t.NonExistenceProof.decode(n,n.uint32());break;case 3:o.batch=t.BatchProof.decode(n,n.uint32());break;case 4:o.compressed=t.CompressedBatchProof.decode(n,n.uint32());break;default:n.skipType(7&e)}}return o},fromJSON(object){const e=Object.assign({},y);return e.exist=void 0!==object.exist&&null!==object.exist?t.ExistenceProof.fromJSON(object.exist):void 0,e.nonexist=void 0!==object.nonexist&&null!==object.nonexist?t.NonExistenceProof.fromJSON(object.nonexist):void 0,e.batch=void 0!==object.batch&&null!==object.batch?t.BatchProof.fromJSON(object.batch):void 0,e.compressed=void 0!==object.compressed&&null!==object.compressed?t.CompressedBatchProof.fromJSON(object.compressed):void 0,e},toJSON(e){const n={};return void 0!==e.exist&&(n.exist=e.exist?t.ExistenceProof.toJSON(e.exist):void 0),void 0!==e.nonexist&&(n.nonexist=e.nonexist?t.NonExistenceProof.toJSON(e.nonexist):void 0),void 0!==e.batch&&(n.batch=e.batch?t.BatchProof.toJSON(e.batch):void 0),void 0!==e.compressed&&(n.compressed=e.compressed?t.CompressedBatchProof.toJSON(e.compressed):void 0),n},fromPartial(object){const e=Object.assign({},y);return e.exist=void 0!==object.exist&&null!==object.exist?t.ExistenceProof.fromPartial(object.exist):void 0,e.nonexist=void 0!==object.nonexist&&null!==object.nonexist?t.NonExistenceProof.fromPartial(object.nonexist):void 0,e.batch=void 0!==object.batch&&null!==object.batch?t.BatchProof.fromPartial(object.batch):void 0,e.compressed=void 0!==object.compressed&&null!==object.compressed?t.CompressedBatchProof.fromPartial(object.compressed):void 0,e}};const E={hash:0,prehashKey:0,prehashValue:0,length:0};t.LeafOp={encode:(e,t=c.default.Writer.create())=>(0!==e.hash&&t.uint32(8).int32(e.hash),0!==e.prehashKey&&t.uint32(16).int32(e.prehashKey),0!==e.prehashValue&&t.uint32(24).int32(e.prehashValue),0!==e.length&&t.uint32(32).int32(e.length),0!==e.prefix.length&&t.uint32(42).bytes(e.prefix),t),decode(input,e){const t=input instanceof c.default.Reader?input:new c.default.Reader(input);let n=void 0===e?t.len:t.pos+e;const r=Object.assign({},E);for(r.prefix=new Uint8Array;t.pos<n;){const e=t.uint32();switch(e>>>3){case 1:r.hash=t.int32();break;case 2:r.prehashKey=t.int32();break;case 3:r.prehashValue=t.int32();break;case 4:r.length=t.int32();break;case 5:r.prefix=t.bytes();break;default:t.skipType(7&e)}}return r},fromJSON(object){const e=Object.assign({},E);return e.hash=void 0!==object.hash&&null!==object.hash?f(object.hash):0,e.prehashKey=void 0!==object.prehashKey&&null!==object.prehashKey?f(object.prehashKey):0,e.prehashValue=void 0!==object.prehashValue&&null!==object.prehashValue?f(object.prehashValue):0,e.length=void 0!==object.length&&null!==object.length?v(object.length):0,e.prefix=void 0!==object.prefix&&null!==object.prefix?J(object.prefix):new Uint8Array,e},toJSON(e){const t={};return void 0!==e.hash&&(t.hash=h(e.hash)),void 0!==e.prehashKey&&(t.prehashKey=h(e.prehashKey)),void 0!==e.prehashValue&&(t.prehashValue=h(e.prehashValue)),void 0!==e.length&&(t.length=m(e.length)),void 0!==e.prefix&&(t.prefix=T(void 0!==e.prefix?e.prefix:new Uint8Array)),t},fromPartial(object){var e,t,n,r,o;const c=Object.assign({},E);return c.hash=null!==(e=object.hash)&&void 0!==e?e:0,c.prehashKey=null!==(t=object.prehashKey)&&void 0!==t?t:0,c.prehashValue=null!==(n=object.prehashValue)&&void 0!==n?n:0,c.length=null!==(r=object.length)&&void 0!==r?r:0,c.prefix=null!==(o=object.prefix)&&void 0!==o?o:new Uint8Array,c}};const S={hash:0};t.InnerOp={encode:(e,t=c.default.Writer.create())=>(0!==e.hash&&t.uint32(8).int32(e.hash),0!==e.prefix.length&&t.uint32(18).bytes(e.prefix),0!==e.suffix.length&&t.uint32(26).bytes(e.suffix),t),decode(input,e){const t=input instanceof c.default.Reader?input:new c.default.Reader(input);let n=void 0===e?t.len:t.pos+e;const r=Object.assign({},S);for(r.prefix=new Uint8Array,r.suffix=new Uint8Array;t.pos<n;){const e=t.uint32();switch(e>>>3){case 1:r.hash=t.int32();break;case 2:r.prefix=t.bytes();break;case 3:r.suffix=t.bytes();break;default:t.skipType(7&e)}}return r},fromJSON(object){const e=Object.assign({},S);return e.hash=void 0!==object.hash&&null!==object.hash?f(object.hash):0,e.prefix=void 0!==object.prefix&&null!==object.prefix?J(object.prefix):new Uint8Array,e.suffix=void 0!==object.suffix&&null!==object.suffix?J(object.suffix):new Uint8Array,e},toJSON(e){const t={};return void 0!==e.hash&&(t.hash=h(e.hash)),void 0!==e.prefix&&(t.prefix=T(void 0!==e.prefix?e.prefix:new Uint8Array)),void 0!==e.suffix&&(t.suffix=T(void 0!==e.suffix?e.suffix:new Uint8Array)),t},fromPartial(object){var e,t,n;const r=Object.assign({},S);return r.hash=null!==(e=object.hash)&&void 0!==e?e:0,r.prefix=null!==(t=object.prefix)&&void 0!==t?t:new Uint8Array,r.suffix=null!==(n=object.suffix)&&void 0!==n?n:new Uint8Array,r}};const P={maxDepth:0,minDepth:0};t.ProofSpec={encode:(e,n=c.default.Writer.create())=>(void 0!==e.leafSpec&&t.LeafOp.encode(e.leafSpec,n.uint32(10).fork()).ldelim(),void 0!==e.innerSpec&&t.InnerSpec.encode(e.innerSpec,n.uint32(18).fork()).ldelim(),0!==e.maxDepth&&n.uint32(24).int32(e.maxDepth),0!==e.minDepth&&n.uint32(32).int32(e.minDepth),n),decode(input,e){const n=input instanceof c.default.Reader?input:new c.default.Reader(input);let r=void 0===e?n.len:n.pos+e;const o=Object.assign({},P);for(;n.pos<r;){const e=n.uint32();switch(e>>>3){case 1:o.leafSpec=t.LeafOp.decode(n,n.uint32());break;case 2:o.innerSpec=t.InnerSpec.decode(n,n.uint32());break;case 3:o.maxDepth=n.int32();break;case 4:o.minDepth=n.int32();break;default:n.skipType(7&e)}}return o},fromJSON(object){const e=Object.assign({},P);return e.leafSpec=void 0!==object.leafSpec&&null!==object.leafSpec?t.LeafOp.fromJSON(object.leafSpec):void 0,e.innerSpec=void 0!==object.innerSpec&&null!==object.innerSpec?t.InnerSpec.fromJSON(object.innerSpec):void 0,e.maxDepth=void 0!==object.maxDepth&&null!==object.maxDepth?Number(object.maxDepth):0,e.minDepth=void 0!==object.minDepth&&null!==object.minDepth?Number(object.minDepth):0,e},toJSON(e){const n={};return void 0!==e.leafSpec&&(n.leafSpec=e.leafSpec?t.LeafOp.toJSON(e.leafSpec):void 0),void 0!==e.innerSpec&&(n.innerSpec=e.innerSpec?t.InnerSpec.toJSON(e.innerSpec):void 0),void 0!==e.maxDepth&&(n.maxDepth=e.maxDepth),void 0!==e.minDepth&&(n.minDepth=e.minDepth),n},fromPartial(object){var e,n;const r=Object.assign({},P);return r.leafSpec=void 0!==object.leafSpec&&null!==object.leafSpec?t.LeafOp.fromPartial(object.leafSpec):void 0,r.innerSpec=void 0!==object.innerSpec&&null!==object.innerSpec?t.InnerSpec.fromPartial(object.innerSpec):void 0,r.maxDepth=null!==(e=object.maxDepth)&&void 0!==e?e:0,r.minDepth=null!==(n=object.minDepth)&&void 0!==n?n:0,r}};const k={childOrder:0,childSize:0,minPrefixLength:0,maxPrefixLength:0,hash:0};t.InnerSpec={encode(e,t=c.default.Writer.create()){t.uint32(10).fork();for(const n of e.childOrder)t.int32(n);return t.ldelim(),0!==e.childSize&&t.uint32(16).int32(e.childSize),0!==e.minPrefixLength&&t.uint32(24).int32(e.minPrefixLength),0!==e.maxPrefixLength&&t.uint32(32).int32(e.maxPrefixLength),0!==e.emptyChild.length&&t.uint32(42).bytes(e.emptyChild),0!==e.hash&&t.uint32(48).int32(e.hash),t},decode(input,e){const t=input instanceof c.default.Reader?input:new c.default.Reader(input);let n=void 0===e?t.len:t.pos+e;const r=Object.assign({},k);for(r.childOrder=[],r.emptyChild=new Uint8Array;t.pos<n;){const e=t.uint32();switch(e>>>3){case 1:if(2==(7&e)){const e=t.uint32()+t.pos;for(;t.pos<e;)r.childOrder.push(t.int32())}else r.childOrder.push(t.int32());break;case 2:r.childSize=t.int32();break;case 3:r.minPrefixLength=t.int32();break;case 4:r.maxPrefixLength=t.int32();break;case 5:r.emptyChild=t.bytes();break;case 6:r.hash=t.int32();break;default:t.skipType(7&e)}}return r},fromJSON(object){var e;const t=Object.assign({},k);return t.childOrder=(null!==(e=object.childOrder)&&void 0!==e?e:[]).map((e=>Number(e))),t.childSize=void 0!==object.childSize&&null!==object.childSize?Number(object.childSize):0,t.minPrefixLength=void 0!==object.minPrefixLength&&null!==object.minPrefixLength?Number(object.minPrefixLength):0,t.maxPrefixLength=void 0!==object.maxPrefixLength&&null!==object.maxPrefixLength?Number(object.maxPrefixLength):0,t.emptyChild=void 0!==object.emptyChild&&null!==object.emptyChild?J(object.emptyChild):new Uint8Array,t.hash=void 0!==object.hash&&null!==object.hash?f(object.hash):0,t},toJSON(e){const t={};return e.childOrder?t.childOrder=e.childOrder.map((e=>e)):t.childOrder=[],void 0!==e.childSize&&(t.childSize=e.childSize),void 0!==e.minPrefixLength&&(t.minPrefixLength=e.minPrefixLength),void 0!==e.maxPrefixLength&&(t.maxPrefixLength=e.maxPrefixLength),void 0!==e.emptyChild&&(t.emptyChild=T(void 0!==e.emptyChild?e.emptyChild:new Uint8Array)),void 0!==e.hash&&(t.hash=h(e.hash)),t},fromPartial(object){var e,t,n,r,o,c;const d=Object.assign({},k);return d.childOrder=(null===(e=object.childOrder)||void 0===e?void 0:e.map((e=>e)))||[],d.childSize=null!==(t=object.childSize)&&void 0!==t?t:0,d.minPrefixLength=null!==(n=object.minPrefixLength)&&void 0!==n?n:0,d.maxPrefixLength=null!==(r=object.maxPrefixLength)&&void 0!==r?r:0,d.emptyChild=null!==(o=object.emptyChild)&&void 0!==o?o:new Uint8Array,d.hash=null!==(c=object.hash)&&void 0!==c?c:0,d}};const N={};t.BatchProof={encode(e,n=c.default.Writer.create()){for(const r of e.entries)t.BatchEntry.encode(r,n.uint32(10).fork()).ldelim();return n},decode(input,e){const n=input instanceof c.default.Reader?input:new c.default.Reader(input);let r=void 0===e?n.len:n.pos+e;const o=Object.assign({},N);for(o.entries=[];n.pos<r;){const e=n.uint32();if(e>>>3==1)o.entries.push(t.BatchEntry.decode(n,n.uint32()));else n.skipType(7&e)}return o},fromJSON(object){var e;const n=Object.assign({},N);return n.entries=(null!==(e=object.entries)&&void 0!==e?e:[]).map((e=>t.BatchEntry.fromJSON(e))),n},toJSON(e){const n={};return e.entries?n.entries=e.entries.map((e=>e?t.BatchEntry.toJSON(e):void 0)):n.entries=[],n},fromPartial(object){var e;const n=Object.assign({},N);return n.entries=(null===(e=object.entries)||void 0===e?void 0:e.map((e=>t.BatchEntry.fromPartial(e))))||[],n}};const I={};t.BatchEntry={encode:(e,n=c.default.Writer.create())=>(void 0!==e.exist&&t.ExistenceProof.encode(e.exist,n.uint32(10).fork()).ldelim(),void 0!==e.nonexist&&t.NonExistenceProof.encode(e.nonexist,n.uint32(18).fork()).ldelim(),n),decode(input,e){const n=input instanceof c.default.Reader?input:new c.default.Reader(input);let r=void 0===e?n.len:n.pos+e;const o=Object.assign({},I);for(;n.pos<r;){const e=n.uint32();switch(e>>>3){case 1:o.exist=t.ExistenceProof.decode(n,n.uint32());break;case 2:o.nonexist=t.NonExistenceProof.decode(n,n.uint32());break;default:n.skipType(7&e)}}return o},fromJSON(object){const e=Object.assign({},I);return e.exist=void 0!==object.exist&&null!==object.exist?t.ExistenceProof.fromJSON(object.exist):void 0,e.nonexist=void 0!==object.nonexist&&null!==object.nonexist?t.NonExistenceProof.fromJSON(object.nonexist):void 0,e},toJSON(e){const n={};return void 0!==e.exist&&(n.exist=e.exist?t.ExistenceProof.toJSON(e.exist):void 0),void 0!==e.nonexist&&(n.nonexist=e.nonexist?t.NonExistenceProof.toJSON(e.nonexist):void 0),n},fromPartial(object){const e=Object.assign({},I);return e.exist=void 0!==object.exist&&null!==object.exist?t.ExistenceProof.fromPartial(object.exist):void 0,e.nonexist=void 0!==object.nonexist&&null!==object.nonexist?t.NonExistenceProof.fromPartial(object.nonexist):void 0,e}};const R={};t.CompressedBatchProof={encode(e,n=c.default.Writer.create()){for(const r of e.entries)t.CompressedBatchEntry.encode(r,n.uint32(10).fork()).ldelim();for(const r of e.lookupInners)t.InnerOp.encode(r,n.uint32(18).fork()).ldelim();return n},decode(input,e){const n=input instanceof c.default.Reader?input:new c.default.Reader(input);let r=void 0===e?n.len:n.pos+e;const o=Object.assign({},R);for(o.entries=[],o.lookupInners=[];n.pos<r;){const e=n.uint32();switch(e>>>3){case 1:o.entries.push(t.CompressedBatchEntry.decode(n,n.uint32()));break;case 2:o.lookupInners.push(t.InnerOp.decode(n,n.uint32()));break;default:n.skipType(7&e)}}return o},fromJSON(object){var e,n;const r=Object.assign({},R);return r.entries=(null!==(e=object.entries)&&void 0!==e?e:[]).map((e=>t.CompressedBatchEntry.fromJSON(e))),r.lookupInners=(null!==(n=object.lookupInners)&&void 0!==n?n:[]).map((e=>t.InnerOp.fromJSON(e))),r},toJSON(e){const n={};return e.entries?n.entries=e.entries.map((e=>e?t.CompressedBatchEntry.toJSON(e):void 0)):n.entries=[],e.lookupInners?n.lookupInners=e.lookupInners.map((e=>e?t.InnerOp.toJSON(e):void 0)):n.lookupInners=[],n},fromPartial(object){var e,n;const r=Object.assign({},R);return r.entries=(null===(e=object.entries)||void 0===e?void 0:e.map((e=>t.CompressedBatchEntry.fromPartial(e))))||[],r.lookupInners=(null===(n=object.lookupInners)||void 0===n?void 0:n.map((e=>t.InnerOp.fromPartial(e))))||[],r}};const w={};t.CompressedBatchEntry={encode:(e,n=c.default.Writer.create())=>(void 0!==e.exist&&t.CompressedExistenceProof.encode(e.exist,n.uint32(10).fork()).ldelim(),void 0!==e.nonexist&&t.CompressedNonExistenceProof.encode(e.nonexist,n.uint32(18).fork()).ldelim(),n),decode(input,e){const n=input instanceof c.default.Reader?input:new c.default.Reader(input);let r=void 0===e?n.len:n.pos+e;const o=Object.assign({},w);for(;n.pos<r;){const e=n.uint32();switch(e>>>3){case 1:o.exist=t.CompressedExistenceProof.decode(n,n.uint32());break;case 2:o.nonexist=t.CompressedNonExistenceProof.decode(n,n.uint32());break;default:n.skipType(7&e)}}return o},fromJSON(object){const e=Object.assign({},w);return e.exist=void 0!==object.exist&&null!==object.exist?t.CompressedExistenceProof.fromJSON(object.exist):void 0,e.nonexist=void 0!==object.nonexist&&null!==object.nonexist?t.CompressedNonExistenceProof.fromJSON(object.nonexist):void 0,e},toJSON(e){const n={};return void 0!==e.exist&&(n.exist=e.exist?t.CompressedExistenceProof.toJSON(e.exist):void 0),void 0!==e.nonexist&&(n.nonexist=e.nonexist?t.CompressedNonExistenceProof.toJSON(e.nonexist):void 0),n},fromPartial(object){const e=Object.assign({},w);return e.exist=void 0!==object.exist&&null!==object.exist?t.CompressedExistenceProof.fromPartial(object.exist):void 0,e.nonexist=void 0!==object.nonexist&&null!==object.nonexist?t.CompressedNonExistenceProof.fromPartial(object.nonexist):void 0,e}};const A={path:0};t.CompressedExistenceProof={encode(e,n=c.default.Writer.create()){0!==e.key.length&&n.uint32(10).bytes(e.key),0!==e.value.length&&n.uint32(18).bytes(e.value),void 0!==e.leaf&&t.LeafOp.encode(e.leaf,n.uint32(26).fork()).ldelim(),n.uint32(34).fork();for(const t of e.path)n.int32(t);return n.ldelim(),n},decode(input,e){const n=input instanceof c.default.Reader?input:new c.default.Reader(input);let r=void 0===e?n.len:n.pos+e;const o=Object.assign({},A);for(o.path=[],o.key=new Uint8Array,o.value=new Uint8Array;n.pos<r;){const e=n.uint32();switch(e>>>3){case 1:o.key=n.bytes();break;case 2:o.value=n.bytes();break;case 3:o.leaf=t.LeafOp.decode(n,n.uint32());break;case 4:if(2==(7&e)){const e=n.uint32()+n.pos;for(;n.pos<e;)o.path.push(n.int32())}else o.path.push(n.int32());break;default:n.skipType(7&e)}}return o},fromJSON(object){var e;const n=Object.assign({},A);return n.key=void 0!==object.key&&null!==object.key?J(object.key):new Uint8Array,n.value=void 0!==object.value&&null!==object.value?J(object.value):new Uint8Array,n.leaf=void 0!==object.leaf&&null!==object.leaf?t.LeafOp.fromJSON(object.leaf):void 0,n.path=(null!==(e=object.path)&&void 0!==e?e:[]).map((e=>Number(e))),n},toJSON(e){const n={};return void 0!==e.key&&(n.key=T(void 0!==e.key?e.key:new Uint8Array)),void 0!==e.value&&(n.value=T(void 0!==e.value?e.value:new Uint8Array)),void 0!==e.leaf&&(n.leaf=e.leaf?t.LeafOp.toJSON(e.leaf):void 0),e.path?n.path=e.path.map((e=>e)):n.path=[],n},fromPartial(object){var e,n,r;const o=Object.assign({},A);return o.key=null!==(e=object.key)&&void 0!==e?e:new Uint8Array,o.value=null!==(n=object.value)&&void 0!==n?n:new Uint8Array,o.leaf=void 0!==object.leaf&&null!==object.leaf?t.LeafOp.fromPartial(object.leaf):void 0,o.path=(null===(r=object.path)||void 0===r?void 0:r.map((e=>e)))||[],o}};const C={};t.CompressedNonExistenceProof={encode:(e,n=c.default.Writer.create())=>(0!==e.key.length&&n.uint32(10).bytes(e.key),void 0!==e.left&&t.CompressedExistenceProof.encode(e.left,n.uint32(18).fork()).ldelim(),void 0!==e.right&&t.CompressedExistenceProof.encode(e.right,n.uint32(26).fork()).ldelim(),n),decode(input,e){const n=input instanceof c.default.Reader?input:new c.default.Reader(input);let r=void 0===e?n.len:n.pos+e;const o=Object.assign({},C);for(o.key=new Uint8Array;n.pos<r;){const e=n.uint32();switch(e>>>3){case 1:o.key=n.bytes();break;case 2:o.left=t.CompressedExistenceProof.decode(n,n.uint32());break;case 3:o.right=t.CompressedExistenceProof.decode(n,n.uint32());break;default:n.skipType(7&e)}}return o},fromJSON(object){const e=Object.assign({},C);return e.key=void 0!==object.key&&null!==object.key?J(object.key):new Uint8Array,e.left=void 0!==object.left&&null!==object.left?t.CompressedExistenceProof.fromJSON(object.left):void 0,e.right=void 0!==object.right&&null!==object.right?t.CompressedExistenceProof.fromJSON(object.right):void 0,e},toJSON(e){const n={};return void 0!==e.key&&(n.key=T(void 0!==e.key?e.key:new Uint8Array)),void 0!==e.left&&(n.left=e.left?t.CompressedExistenceProof.toJSON(e.left):void 0),void 0!==e.right&&(n.right=e.right?t.CompressedExistenceProof.toJSON(e.right):void 0),n},fromPartial(object){var e;const n=Object.assign({},C);return n.key=null!==(e=object.key)&&void 0!==e?e:new Uint8Array,n.left=void 0!==object.left&&null!==object.left?t.CompressedExistenceProof.fromPartial(object.left):void 0,n.right=void 0!==object.right&&null!==object.right?t.CompressedExistenceProof.fromPartial(object.right):void 0,n}};var L=(()=>{if(void 0!==L)return L;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if(void 0!==e)return e;throw"Unable to locate global object"})();const _=L.atob||(e=>L.Buffer.from(e,"base64").toString("binary"));function J(e){const t=_(e),n=new Uint8Array(t.length);for(let i=0;i<t.length;++i)n[i]=t.charCodeAt(i);return n}const B=L.btoa||(e=>L.Buffer.from(e,"binary").toString("base64"));function T(e){const t=[];for(const n of e)t.push(String.fromCharCode(n));return B(t.join(""))}c.default.util.Long!==o.default&&(c.default.util.Long=o.default,c.default.configure())}).call(this,n(31))},2130:function(e,t,n){const r=n(2131),{hexStringToBuffer:o,profiles:c}=n(2139),{cidV0ToV1Base32:d}=n(2160);e.exports={helpers:{cidV0ToV1Base32:d},decode:function(e){const t=o(e),n=r.getCodec(t),d=r.rmPrefix(t);let l=c[n];return l||(l=c.default),l.decode(d)},fromIpfs:function(e){return this.encode("ipfs-ns",e)},fromSwarm:function(e){return this.encode("swarm-ns",e)},encode:function(e,t){let n=c[e];n||(n=c.default);const o=n.encode(t);return r.addPrefix(e,o).toString("hex")},getCodec:function(e){let t=o(e);return r.getCodec(t)}}},2139:function(e,t,n){(function(e){const r=n(1205),o=n(827),c=e=>{let t=e.slice(0,2),n=e.slice(2),r="";return r="0x"===t?n:e,o.fromHexString(r)},d={swarm:e=>{const t=o.encode(c(e),"keccak-256");return new r(1,"swarm-manifest",t).buffer},ipfs:e=>{const t=o.fromB58String(e);return new r(1,"dag-pb",t).buffer},utf8:t=>e.from(t,"utf8")},l={hexMultiHash:e=>{const t=new r(e);return o.decode(t.multihash).digest.toString("hex")},b58MultiHash:e=>{const t=new r(e);return o.toB58String(t.multihash)},utf8:e=>e.toString("utf8")},f={"swarm-ns":{encode:d.swarm,decode:l.hexMultiHash},"ipfs-ns":{encode:d.ipfs,decode:l.b58MultiHash},"ipns-ns":{encode:d.ipfs,decode:l.b58MultiHash},default:{encode:d.utf8,decode:l.utf8}};t.hexStringToBuffer=c,t.profiles=f}).call(this,n(20).Buffer)},2160:function(e,t,n){const r=n(1205);t.cidV0ToV1Base32=e=>{let t=new r(e);return 0===t.version&&(t=t.toV1()),t.toString("base32")}},478:function(e,t,n){function r(e){return Object.prototype.toString.call(e)}t.isArray=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===r(e)},t.isBoolean=function(e){return"boolean"==typeof e},t.isNull=function(e){return null===e},t.isNullOrUndefined=function(e){return null==e},t.isNumber=function(e){return"number"==typeof e},t.isString=function(e){return"string"==typeof e},t.isSymbol=function(e){return"symbol"==typeof e},t.isUndefined=function(e){return void 0===e},t.isRegExp=function(e){return"[object RegExp]"===r(e)},t.isObject=function(e){return"object"==typeof e&&null!==e},t.isDate=function(e){return"[object Date]"===r(e)},t.isError=function(e){return"[object Error]"===r(e)||e instanceof Error},t.isFunction=function(e){return"function"==typeof e},t.isPrimitive=function(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e},t.isBuffer=n(20).Buffer.isBuffer}}]);