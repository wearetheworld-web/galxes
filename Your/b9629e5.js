(window.webpackJsonp=window.webpackJsonp||[]).push([[1127],{1240:function(t,e,n){"use strict";n.d(e,"a",(function(){return k}));var r=n(308),o=n(279),h=n(426),l=n(498),c=n(650),d=n(651),f=n(652),m=n(653),w=n(7);class k{get scaleY(){return k.yDown?-this._scaleY:this._scaleY}set scaleY(t){this._scaleY=t}constructor(data){if(this._updateCache=new Array,this.skin=null,this.scaleX=1,this._scaleY=1,this.x=0,this.y=0,!data)throw new Error("data cannot be null.");this.data=data,this.bones=new Array;for(let i=0;i<data.bones.length;i++){let t,e=data.bones[i];if(e.parent){let n=this.bones[e.parent.index];t=new l.a(e,this,n),n.children.push(t)}else t=new l.a(e,this,null);this.bones.push(t)}this.slots=new Array,this.drawOrder=new Array;for(let i=0;i<data.slots.length;i++){let t=data.slots[i],e=this.bones[t.boneData.index],slot=new f.a(t,e);this.slots.push(slot),this.drawOrder.push(slot)}this.ikConstraints=new Array;for(let i=0;i<data.ikConstraints.length;i++){let t=data.ikConstraints[i];this.ikConstraints.push(new c.a(t,this))}this.transformConstraints=new Array;for(let i=0;i<data.transformConstraints.length;i++){let t=data.transformConstraints[i];this.transformConstraints.push(new m.a(t,this))}this.pathConstraints=new Array;for(let i=0;i<data.pathConstraints.length;i++){let t=data.pathConstraints[i];this.pathConstraints.push(new d.a(t,this))}this.color=new w.a(1,1,1,1),this.updateCache()}updateCache(){this._updateCache.length=0;let t=this.bones;for(let i=0,e=t.length;i<e;i++){let e=t[i];e.sorted=e.data.skinRequired,e.active=!e.sorted}if(this.skin){let t=this.skin.bones;for(let i=0,e=this.skin.bones.length;i<e;i++){let e=this.bones[t[i].index];do{e.sorted=!1,e.active=!0,e=e.parent}while(e)}}let e=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,o=e.length,h=n.length,l=r.length,c=o+h+l;t:for(let i=0;i<c;i++){for(let t=0;t<o;t++){let n=e[t];if(n.data.order==i){this.sortIkConstraint(n);continue t}}for(let t=0;t<h;t++){let e=n[t];if(e.data.order==i){this.sortTransformConstraint(e);continue t}}for(let t=0;t<l;t++){let e=r[t];if(e.data.order==i){this.sortPathConstraint(e);continue t}}}for(let i=0,e=t.length;i<e;i++)this.sortBone(t[i])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&w.k.contains(this.skin.constraints,t.data,!0)),!t.active)return;let e=t.target;this.sortBone(e);let n=t.bones,r=n[0];if(this.sortBone(r),1==n.length)this._updateCache.push(t),this.sortReset(r.children);else{let e=n[n.length-1];this.sortBone(e),this._updateCache.push(t),this.sortReset(r.children),e.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&w.k.contains(this.skin.constraints,t.data,!0)),!t.active)return;let slot=t.target,e=slot.data.index,n=slot.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,e,n),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,e,n);for(let i=0,t=this.data.skins.length;i<t;i++)this.sortPathConstraintAttachment(this.data.skins[i],e,n);let r=slot.getAttachment();r instanceof o.a&&this.sortPathConstraintAttachmentWith(r,n);let h=t.bones,l=h.length;for(let i=0;i<l;i++)this.sortBone(h[i]);this._updateCache.push(t);for(let i=0;i<l;i++)this.sortReset(h[i].children);for(let i=0;i<l;i++)h[i].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&w.k.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);let e=t.bones,n=e.length;if(t.data.local)for(let i=0;i<n;i++){let t=e[i];this.sortBone(t.parent),this.sortBone(t)}else for(let i=0;i<n;i++)this.sortBone(e[i]);this._updateCache.push(t);for(let i=0;i<n;i++)this.sortReset(e[i].children);for(let i=0;i<n;i++)e[i].sorted=!0}sortPathConstraintAttachment(t,e,n){let r=t.attachments[e];if(r)for(let t in r)this.sortPathConstraintAttachmentWith(r[t],n)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof o.a))return;let n=t.bones;if(n){let t=this.bones;for(let i=0,e=n.length;i<e;){let e=n[i++];for(e+=i;i<e;)this.sortBone(t[n[i++]])}}else this.sortBone(e)}sortBone(t){if(!t)return;if(t.sorted)return;let e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let i=0,e=t.length;i<e;i++){let e=t[i];e.active&&(e.sorted&&this.sortReset(e.children),e.sorted=!1)}}updateWorldTransform(){let t=this.bones;for(let i=0,e=t.length;i<e;i++){let e=t[i];e.ax=e.x,e.ay=e.y,e.arotation=e.rotation,e.ascaleX=e.scaleX,e.ascaleY=e.scaleY,e.ashearX=e.shearX,e.ashearY=e.shearY}let e=this._updateCache;for(let i=0,t=e.length;i<t;i++)e[i].update()}updateWorldTransformWith(t){let e=this.getRootBone();if(!e)throw new Error("Root bone must not be null.");let n=t.a,r=t.b,o=t.c,h=t.d;e.worldX=n*this.x+r*this.y+t.worldX,e.worldY=o*this.x+h*this.y+t.worldY;let l=e.rotation+90+e.shearY,c=w.e.cosDeg(e.rotation+e.shearX)*e.scaleX,d=w.e.cosDeg(l)*e.scaleY,f=w.e.sinDeg(e.rotation+e.shearX)*e.scaleX,m=w.e.sinDeg(l)*e.scaleY;e.a=(n*c+r*f)*this.scaleX,e.b=(n*d+r*m)*this.scaleX,e.c=(o*c+h*f)*this.scaleY,e.d=(o*d+h*m)*this.scaleY;let k=this._updateCache;for(let i=0,t=k.length;i<t;i++){let t=k[i];t!=e&&t.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){let t=this.bones;for(let i=0,e=t.length;i<e;i++)t[i].setToSetupPose();let e=this.ikConstraints;for(let i=0,t=e.length;i<t;i++){let t=e[i];t.mix=t.data.mix,t.softness=t.data.softness,t.bendDirection=t.data.bendDirection,t.compress=t.data.compress,t.stretch=t.data.stretch}let n=this.transformConstraints;for(let i=0,t=n.length;i<t;i++){let t=n[i],data=t.data;t.mixRotate=data.mixRotate,t.mixX=data.mixX,t.mixY=data.mixY,t.mixScaleX=data.mixScaleX,t.mixScaleY=data.mixScaleY,t.mixShearY=data.mixShearY}let r=this.pathConstraints;for(let i=0,t=r.length;i<t;i++){let t=r[i],data=t.data;t.position=data.position,t.spacing=data.spacing,t.mixRotate=data.mixRotate,t.mixX=data.mixX,t.mixY=data.mixY}}setSlotsToSetupPose(){let t=this.slots;w.k.arrayCopy(t,0,this.drawOrder,0,t.length);for(let i=0,e=t.length;i<e;i++)t[i].setToSetupPose()}getRootBone(){return 0==this.bones.length?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");let e=this.bones;for(let i=0,n=e.length;i<n;i++){let n=e[i];if(n.data.name==t)return n}return null}findSlot(t){if(!t)throw new Error("slotName cannot be null.");let e=this.slots;for(let i=0,n=e.length;i<n;i++){let slot=e[i];if(slot.data.name==t)return slot}return null}setSkinByName(t){let e=this.data.findSkin(t);if(!e)throw new Error("Skin not found: "+t);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{let e=this.slots;for(let i=0,n=e.length;i<n;i++){let slot=e[i],n=slot.data.attachmentName;if(n){let e=t.getAttachment(i,n);e&&slot.setAttachment(e)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){let slot=this.data.findSlot(t);if(!slot)throw new Error(`Can't find slot with name ${t}`);return this.getAttachment(slot.index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){let n=this.skin.getAttachment(t,e);if(n)return n}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");let n=this.slots;for(let i=0,r=n.length;i<r;i++){let slot=n[i];if(slot.data.name==t){let n=null;if(e&&(n=this.getAttachment(i,e),!n))throw new Error("Attachment not found: "+e+", for slot: "+t);return void slot.setAttachment(n)}}throw new Error("Slot not found: "+t)}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");let e=this.ikConstraints;for(let i=0,n=e.length;i<n;i++){let n=e[i];if(n.data.name==t)return n}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");let e=this.transformConstraints;for(let i=0,n=e.length;i<n;i++){let n=e[i];if(n.data.name==t)return n}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");let e=this.pathConstraints;for(let i=0,n=e.length;i<n;i++){let n=e[i];if(n.data.name==t)return n}return null}getBoundsRect(){let t=new w.l,e=new w.l;return this.getBounds(t,e),{x:t.x,y:t.y,width:e.x,height:e.y}}getBounds(t,e,n=new Array(2)){if(!t)throw new Error("offset cannot be null.");if(!e)throw new Error("size cannot be null.");let o=this.drawOrder,l=Number.POSITIVE_INFINITY,c=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,f=Number.NEGATIVE_INFINITY;for(let i=0,t=o.length;i<t;i++){let slot=o[i];if(!slot.bone.active)continue;let t=0,e=null,m=slot.getAttachment();if(m instanceof h.a)t=8,e=w.k.setArraySize(n,t,0),m.computeWorldVertices(slot,e,0,2);else if(m instanceof r.a){let r=m;t=r.worldVerticesLength,e=w.k.setArraySize(n,t,0),r.computeWorldVertices(slot,0,t,e,0,2)}if(e)for(let t=0,n=e.length;t<n;t+=2){let n=e[t],r=e[t+1];l=Math.min(l,n),c=Math.min(c,r),d=Math.max(d,n),f=Math.max(f,r)}}t.set(l,c),e.set(d-l,f-c)}}k.yDown=!1}}]);