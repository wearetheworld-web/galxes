(window.webpackJsonp=window.webpackJsonp||[]).push([[1212],{1244:function(e,t,n){"use strict";n.d(t,"a",(function(){return v}));var r=n(27),l=n(124),o=n(428),h=n(427),f=n(429),m=n(90),d=n(430),c=n(359),w=n(360),k=n(431),x=n(7),S=n(162);class v{constructor(e){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=e}readSkeletonData(e){let t=this.scale,n=new d.a,r="string"==typeof e?JSON.parse(e):e,h=r.skeleton;if(h&&(n.hash=h.hash,n.version=h.spine,n.x=h.x,n.y=h.y,n.width=h.width,n.height=h.height,n.fps=h.fps,n.imagesPath=h.images),r.bones)for(let i=0;i<r.bones.length;i++){let e=r.bones[i],o=null,h=F(e,"parent",null);h&&(o=n.findBone(h));let data=new l.a(n.bones.length,e.name,o);data.length=F(e,"length",0)*t,data.x=F(e,"x",0)*t,data.y=F(e,"y",0)*t,data.rotation=F(e,"rotation",0),data.scaleX=F(e,"scaleX",1),data.scaleY=F(e,"scaleY",1),data.shearX=F(e,"shearX",0),data.shearY=F(e,"shearY",0),data.transformMode=x.k.enumValue(l.b,F(e,"transform","Normal")),data.skinRequired=F(e,"skin",!1);let f=F(e,"color",null);f&&data.color.setFromString(f),n.bones.push(data)}if(r.slots)for(let i=0;i<r.slots.length;i++){let e=r.slots[i],t=n.findBone(e.bone);if(!t)throw new Error(`Couldn't find bone ${e.bone} for slot ${e.name}`);let data=new w.b(n.slots.length,e.name,t),l=F(e,"color",null);l&&data.color.setFromString(l);let o=F(e,"dark",null);o&&(data.darkColor=x.a.fromString(o)),data.attachmentName=F(e,"attachment",null),data.blendMode=x.k.enumValue(w.a,F(e,"blend","normal")),n.slots.push(data)}if(r.ik)for(let i=0;i<r.ik.length;i++){let e=r.ik[i],data=new f.a(e.name);data.order=F(e,"order",0),data.skinRequired=F(e,"skin",!1);for(let t=0;t<e.bones.length;t++){let r=n.findBone(e.bones[t]);if(!r)throw new Error(`Couldn't find bone ${e.bones[t]} for IK constraint ${e.name}.`);data.bones.push(r)}let l=n.findBone(e.target);if(!l)throw new Error(`Couldn't find target bone ${e.target} for IK constraint ${e.name}.`);data.target=l,data.mix=F(e,"mix",1),data.softness=F(e,"softness",0)*t,data.bendDirection=F(e,"bendPositive",!0)?1:-1,data.compress=F(e,"compress",!1),data.stretch=F(e,"stretch",!1),data.uniform=F(e,"uniform",!1),n.ikConstraints.push(data)}if(r.transform)for(let i=0;i<r.transform.length;i++){let e=r.transform[i],data=new k.a(e.name);data.order=F(e,"order",0),data.skinRequired=F(e,"skin",!1);for(let t=0;t<e.bones.length;t++){let r=e.bones[t],l=n.findBone(r);if(!l)throw new Error(`Couldn't find bone ${r} for transform constraint ${e.name}.`);data.bones.push(l)}let l=e.target,o=n.findBone(l);if(!o)throw new Error(`Couldn't find target bone ${l} for transform constraint ${e.name}.`);data.target=o,data.local=F(e,"local",!1),data.relative=F(e,"relative",!1),data.offsetRotation=F(e,"rotation",0),data.offsetX=F(e,"x",0)*t,data.offsetY=F(e,"y",0)*t,data.offsetScaleX=F(e,"scaleX",0),data.offsetScaleY=F(e,"scaleY",0),data.offsetShearY=F(e,"shearY",0),data.mixRotate=F(e,"mixRotate",1),data.mixX=F(e,"mixX",1),data.mixY=F(e,"mixY",data.mixX),data.mixScaleX=F(e,"mixScaleX",1),data.mixScaleY=F(e,"mixScaleY",data.mixScaleX),data.mixShearY=F(e,"mixShearY",1),n.transformConstraints.push(data)}if(r.path)for(let i=0;i<r.path.length;i++){let e=r.path[i],data=new m.a(e.name);data.order=F(e,"order",0),data.skinRequired=F(e,"skin",!1);for(let t=0;t<e.bones.length;t++){let r=e.bones[t],l=n.findBone(r);if(!l)throw new Error(`Couldn't find bone ${r} for path constraint ${e.name}.`);data.bones.push(l)}let l=e.target,o=n.findSlot(l);if(!o)throw new Error(`Couldn't find target slot ${l} for path constraint ${e.name}.`);data.target=o,data.positionMode=x.k.enumValue(m.b,F(e,"positionMode","Percent")),data.spacingMode=x.k.enumValue(m.d,F(e,"spacingMode","Length")),data.rotateMode=x.k.enumValue(m.c,F(e,"rotateMode","Tangent")),data.offsetRotation=F(e,"rotation",0),data.position=F(e,"position",0),data.positionMode==m.b.Fixed&&(data.position*=t),data.spacing=F(e,"spacing",0),data.spacingMode!=m.d.Length&&data.spacingMode!=m.d.Fixed||(data.spacing*=t),data.mixRotate=F(e,"mixRotate",1),data.mixX=F(e,"mixX",1),data.mixY=F(e,"mixY",data.mixX),n.pathConstraints.push(data)}if(r.skins)for(let i=0;i<r.skins.length;i++){let e=r.skins[i],t=new c.a(e.name);if(e.bones)for(let r=0;r<e.bones.length;r++){let l=e.bones[r],o=n.findBone(l);if(!o)throw new Error(`Couldn't find bone ${l} for skin ${e.name}.`);t.bones.push(o)}if(e.ik)for(let r=0;r<e.ik.length;r++){let l=e.ik[r],o=n.findIkConstraint(l);if(!o)throw new Error(`Couldn't find IK constraint ${l} for skin ${e.name}.`);t.constraints.push(o)}if(e.transform)for(let r=0;r<e.transform.length;r++){let l=e.transform[r],o=n.findTransformConstraint(l);if(!o)throw new Error(`Couldn't find transform constraint ${l} for skin ${e.name}.`);t.constraints.push(o)}if(e.path)for(let r=0;r<e.path.length;r++){let l=e.path[r],o=n.findPathConstraint(l);if(!o)throw new Error(`Couldn't find path constraint ${l} for skin ${e.name}.`);t.constraints.push(o)}for(let r in e.attachments){let slot=n.findSlot(r);if(!slot)throw new Error(`Couldn't find slot ${r} for skin ${e.name}.`);let l=e.attachments[r];for(let e in l){let r=this.readAttachment(l[e],t,slot.index,e,n);r&&t.setAttachment(slot.index,e,r)}}n.skins.push(t),"default"==t.name&&(n.defaultSkin=t)}for(let i=0,e=this.linkedMeshes.length;i<e;i++){let e=this.linkedMeshes[i],t=e.skin?n.findSkin(e.skin):n.defaultSkin;if(!t)throw new Error(`Skin not found: ${e.skin}`);let r=t.getAttachment(e.slotIndex,e.parent);if(!r)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.timelineAttachment=e.inheritTimeline?r:e.mesh,e.mesh.setParentMesh(r),null!=e.mesh.region&&e.mesh.updateRegion()}if(this.linkedMeshes.length=0,r.events)for(let e in r.events){let t=r.events[e],data=new o.a(e);data.intValue=F(t,"int",0),data.floatValue=F(t,"float",0),data.stringValue=F(t,"string",""),data.audioPath=F(t,"audio",null),data.audioPath&&(data.volume=F(t,"volume",1),data.balance=F(t,"balance",0)),n.events.push(data)}if(r.animations)for(let e in r.animations){let t=r.animations[e];this.readAnimation(t,e,n)}return n}readAttachment(map,e,t,n,r){let l=this.scale;switch(n=F(map,"name",n),F(map,"type","region")){case"region":{let path=F(map,"path",n),t=this.readSequence(F(map,"sequence",null)),r=this.attachmentLoader.newRegionAttachment(e,n,path,t);if(!r)return null;r.path=path,r.x=F(map,"x",0)*l,r.y=F(map,"y",0)*l,r.scaleX=F(map,"scaleX",1),r.scaleY=F(map,"scaleY",1),r.rotation=F(map,"rotation",0),r.width=map.width*l,r.height=map.height*l,r.sequence=t;let o=F(map,"color",null);return o&&r.color.setFromString(o),null!=r.region&&r.updateRegion(),r}case"boundingbox":{let t=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(!t)return null;this.readVertices(map,t,map.vertexCount<<1);let r=F(map,"color",null);return r&&t.color.setFromString(r),t}case"mesh":case"linkedmesh":{let path=F(map,"path",n),r=this.readSequence(F(map,"sequence",null)),o=this.attachmentLoader.newMeshAttachment(e,n,path,r);if(!o)return null;o.path=path;let h=F(map,"color",null);h&&o.color.setFromString(h),o.width=F(map,"width",0)*l,o.height=F(map,"height",0)*l,o.sequence=r;let f=F(map,"parent",null);if(f)return this.linkedMeshes.push(new y(o,F(map,"skin",null),t,f,F(map,"timelines",!0))),o;let m=map.uvs;return this.readVertices(map,o,m.length),o.triangles=map.triangles,o.regionUVs=m,null!=o.region&&o.updateRegion(),o.edges=F(map,"edges",null),o.hullLength=2*F(map,"hull",0),o}case"path":{let path=this.attachmentLoader.newPathAttachment(e,n);if(!path)return null;path.closed=F(map,"closed",!1),path.constantSpeed=F(map,"constantSpeed",!0);let t=map.vertexCount;this.readVertices(map,path,t<<1);let r=x.k.newArray(t/3,0);for(let i=0;i<map.lengths.length;i++)r[i]=map.lengths[i]*l;path.lengths=r;let o=F(map,"color",null);return o&&path.color.setFromString(o),path}case"point":{let t=this.attachmentLoader.newPointAttachment(e,n);if(!t)return null;t.x=F(map,"x",0)*l,t.y=F(map,"y",0)*l,t.rotation=F(map,"rotation",0);let r=F(map,"color",null);return r&&t.color.setFromString(r),t}case"clipping":{let t=this.attachmentLoader.newClippingAttachment(e,n);if(!t)return null;let l=F(map,"end",null);l&&(t.endSlot=r.findSlot(l));let o=map.vertexCount;this.readVertices(map,t,o<<1);let h=F(map,"color",null);return h&&t.color.setFromString(h),t}}return null}readSequence(map){if(null==map)return null;let e=new S.a(F(map,"count",0));return e.start=F(map,"start",1),e.digits=F(map,"digits",0),e.setupIndex=F(map,"setup",0),e}readVertices(map,e,t){let n=this.scale;e.worldVerticesLength=t;let r=map.vertices;if(t==r.length){let t=x.k.toFloatArray(r);if(1!=n)for(let i=0,e=r.length;i<e;i++)t[i]*=n;return void(e.vertices=t)}let l=new Array,o=new Array;for(let i=0,e=r.length;i<e;){let e=r[i++];o.push(e);for(let t=i+4*e;i<t;i+=4)o.push(r[i]),l.push(r[i+1]*n),l.push(r[i+2]*n),l.push(r[i+3])}e.bones=o,e.vertices=x.k.toFloatArray(l)}readAnimation(map,e,t){let n=this.scale,l=new Array;if(map.slots)for(let e in map.slots){let n=map.slots[e],slot=t.findSlot(e);if(!slot)throw new Error("Slot not found: "+e);let o=slot.index;for(let e in n){let t=n[e];if(!t)continue;let h=t.length;if("attachment"==e){let e=new r.c(h,o);for(let n=0;n<h;n++){let r=t[n];e.setFrame(n,F(r,"time",0),F(r,"name",null))}l.push(e)}else if("rgba"==e){let e=new r.r(h,h<<2,o),n=t[0],time=F(n,"time",0),f=x.a.fromString(n.color);for(let r=0,l=0;;r++){e.setFrame(r,time,f.r,f.g,f.b,f.a);let o=t[r+1];if(!o){e.shrink(l);break}let h=F(o,"time",0),m=x.a.fromString(o.color),d=n.curve;d&&(l=E(d,e,l,r,0,time,h,f.r,m.r,1),l=E(d,e,l,r,1,time,h,f.g,m.g,1),l=E(d,e,l,r,2,time,h,f.b,m.b,1),l=E(d,e,l,r,3,time,h,f.a,m.a,1)),time=h,f=m,n=o}l.push(e)}else if("rgb"==e){let e=new r.s(h,3*h,o),n=t[0],time=F(n,"time",0),f=x.a.fromString(n.color);for(let r=0,l=0;;r++){e.setFrame(r,time,f.r,f.g,f.b);let o=t[r+1];if(!o){e.shrink(l);break}let h=F(o,"time",0),m=x.a.fromString(o.color),d=n.curve;d&&(l=E(d,e,l,r,0,time,h,f.r,m.r,1),l=E(d,e,l,r,1,time,h,f.g,m.g,1),l=E(d,e,l,r,2,time,h,f.b,m.b,1)),time=h,f=m,n=o}l.push(e)}else if("alpha"==e)l.push(C(t,new r.a(h,h,o),0,1));else if("rgba2"==e){let e=new r.q(h,7*h,o),n=t[0],time=F(n,"time",0),f=x.a.fromString(n.light),m=x.a.fromString(n.dark);for(let r=0,l=0;;r++){e.setFrame(r,time,f.r,f.g,f.b,f.a,m.r,m.g,m.b);let o=t[r+1];if(!o){e.shrink(l);break}let h=F(o,"time",0),d=x.a.fromString(o.light),c=x.a.fromString(o.dark),w=n.curve;w&&(l=E(w,e,l,r,0,time,h,f.r,d.r,1),l=E(w,e,l,r,1,time,h,f.g,d.g,1),l=E(w,e,l,r,2,time,h,f.b,d.b,1),l=E(w,e,l,r,3,time,h,f.a,d.a,1),l=E(w,e,l,r,4,time,h,m.r,c.r,1),l=E(w,e,l,r,5,time,h,m.g,c.g,1),l=E(w,e,l,r,6,time,h,m.b,c.b,1)),time=h,f=d,m=c,n=o}l.push(e)}else if("rgb2"==e){let e=new r.p(h,6*h,o),n=t[0],time=F(n,"time",0),f=x.a.fromString(n.light),m=x.a.fromString(n.dark);for(let r=0,l=0;;r++){e.setFrame(r,time,f.r,f.g,f.b,m.r,m.g,m.b);let o=t[r+1];if(!o){e.shrink(l);break}let h=F(o,"time",0),d=x.a.fromString(o.light),c=x.a.fromString(o.dark),w=n.curve;w&&(l=E(w,e,l,r,0,time,h,f.r,d.r,1),l=E(w,e,l,r,1,time,h,f.g,d.g,1),l=E(w,e,l,r,2,time,h,f.b,d.b,1),l=E(w,e,l,r,3,time,h,m.r,c.r,1),l=E(w,e,l,r,4,time,h,m.g,c.g,1),l=E(w,e,l,r,5,time,h,m.b,c.b,1)),time=h,f=d,m=c,n=o}l.push(e)}}}if(map.bones)for(let e in map.bones){let o=map.bones[e],h=t.findBone(e);if(!h)throw new Error("Bone not found: "+e);let f=h.index;for(let e in o){let t=o[e],h=t.length;if(0!=h)if("rotate"===e)l.push(C(t,new r.t(h,h,f),0,1));else if("translate"===e){let e=new r.D(h,h<<1,f);l.push(A(t,e,"x","y",0,n))}else if("translatex"===e){let e=new r.E(h,h,f);l.push(C(t,e,0,n))}else if("translatey"===e){let e=new r.F(h,h,f);l.push(C(t,e,0,n))}else if("scale"===e){let e=new r.u(h,h<<1,f);l.push(A(t,e,"x","y",1,1))}else if("scalex"===e){let e=new r.v(h,h,f);l.push(C(t,e,1,1))}else if("scaley"===e){let e=new r.w(h,h,f);l.push(C(t,e,1,1))}else if("shear"===e){let e=new r.y(h,h<<1,f);l.push(A(t,e,"x","y",0,1))}else if("shearx"===e){let e=new r.z(h,h,f);l.push(C(t,e,0,1))}else if("sheary"===e){let e=new r.A(h,h,f);l.push(C(t,e,0,1))}}}if(map.ik)for(let e in map.ik){let o=map.ik[e],h=o[0];if(!h)continue;let f=t.findIkConstraint(e);if(!f)throw new Error("IK Constraint not found: "+e);let m=t.ikConstraints.indexOf(f),d=new r.j(o.length,o.length<<1,m),time=F(h,"time",0),c=F(h,"mix",1),w=F(h,"softness",0)*n;for(let e=0,t=0;;e++){d.setFrame(e,time,c,w,F(h,"bendPositive",!0)?1:-1,F(h,"compress",!1),F(h,"stretch",!1));let r=o[e+1];if(!r){d.shrink(t);break}let l=F(r,"time",0),f=F(r,"mix",1),m=F(r,"softness",0)*n,k=h.curve;k&&(t=E(k,d,t,e,0,time,l,c,f,1),t=E(k,d,t,e,1,time,l,w,m,n)),time=l,c=f,w=m,h=r}l.push(d)}if(map.transform)for(let e in map.transform){let n=map.transform[e],o=n[0];if(!o)continue;let h=t.findTransformConstraint(e);if(!h)throw new Error("Transform constraint not found: "+e);let f=t.transformConstraints.indexOf(h),m=new r.C(n.length,6*n.length,f),time=F(o,"time",0),d=F(o,"mixRotate",1),c=F(o,"mixX",1),w=F(o,"mixY",c),k=F(o,"mixScaleX",1),x=F(o,"mixScaleY",k),S=F(o,"mixShearY",1);for(let e=0,t=0;;e++){m.setFrame(e,time,d,c,w,k,x,S);let r=n[e+1];if(!r){m.shrink(t);break}let l=F(r,"time",0),h=F(r,"mixRotate",1),f=F(r,"mixX",1),v=F(r,"mixY",f),y=F(r,"mixScaleX",1),C=F(r,"mixScaleY",y),A=F(r,"mixShearY",1),Y=o.curve;Y&&(t=E(Y,m,t,e,0,time,l,d,h,1),t=E(Y,m,t,e,1,time,l,c,f,1),t=E(Y,m,t,e,2,time,l,w,v,1),t=E(Y,m,t,e,3,time,l,k,y,1),t=E(Y,m,t,e,4,time,l,x,C,1),t=E(Y,m,t,e,5,time,l,S,A,1)),time=l,d=h,c=f,w=v,k=y,x=C,k=y,o=r}l.push(m)}if(map.path)for(let e in map.path){let o=map.path[e],h=t.findPathConstraint(e);if(!h)throw new Error("Path constraint not found: "+e);let f=t.pathConstraints.indexOf(h);for(let e in o){let t=o[e],d=t[0];if(!d)continue;let c=t.length;if("position"===e){let e=new r.n(c,c,f);l.push(C(t,e,0,h.positionMode==m.b.Fixed?n:1))}else if("spacing"===e){let e=new r.o(c,c,f);l.push(C(t,e,0,h.spacingMode==m.d.Length||h.spacingMode==m.d.Fixed?n:1))}else if("mix"===e){let e=new r.m(c,3*c,f),time=F(d,"time",0),n=F(d,"mixRotate",1),o=F(d,"mixX",1),h=F(d,"mixY",o);for(let r=0,l=0;;r++){e.setFrame(r,time,n,o,h);let f=t[r+1];if(!f){e.shrink(l);break}let m=F(f,"time",0),c=F(f,"mixRotate",1),w=F(f,"mixX",1),k=F(f,"mixY",w),x=d.curve;x&&(l=E(x,e,l,r,0,time,m,n,c,1),l=E(x,e,l,r,1,time,m,o,w,1),l=E(x,e,l,r,2,time,m,h,k,1)),time=m,n=c,o=w,h=k,d=f}l.push(e)}}}if(map.attachments)for(let e in map.attachments){let o=map.attachments[e],h=t.findSkin(e);if(!h)throw new Error("Skin not found: "+e);for(let e in o){let f=o[e],slot=t.findSlot(e);if(!slot)throw new Error("Slot not found: "+e);let m=slot.index;for(let e in f){let t=f[e],o=h.getAttachment(m,e);for(let e in t){let h=t[e],f=h[0];if(f)if("deform"==e){let e=o.bones,t=o.vertices,d=e?t.length/3*2:t.length,c=new r.g(h.length,h.length,m,o),time=F(f,"time",0);for(let r=0,l=0;;r++){let o,m=F(f,"vertices",null);if(m){o=x.k.newFloatArray(d);let r=F(f,"offset",0);if(x.k.arrayCopy(m,0,o,r,m.length),1!=n)for(let i=r,e=i+m.length;i<e;i++)o[i]*=n;if(!e)for(let i=0;i<d;i++)o[i]+=t[i]}else o=e?x.k.newFloatArray(d):t;c.setFrame(r,time,o);let w=h[r+1];if(!w){c.shrink(l);break}let k=F(w,"time",0),S=f.curve;S&&(l=E(S,c,l,r,0,time,k,0,1,1)),time=k,f=w}l.push(c)}else if("sequence"==e){let e=new r.x(h.length,m,o),t=0;for(let n=0;n<h.length;n++){let r=F(f,"delay",t),time=F(f,"time",0),l=S.b[F(f,"mode","hold")],o=F(f,"index",0);e.setFrame(n,time,l,o,r),t=r,f=h[n+1]}l.push(e)}}}}}if(map.drawOrder){let e=new r.h(map.drawOrder.length),n=t.slots.length,o=0;for(let i=0;i<map.drawOrder.length;i++,o++){let r=map.drawOrder[i],l=null,h=F(r,"offsets",null);if(h){l=x.k.newArray(n,-1);let e=x.k.newArray(n-h.length,0),r=0,o=0;for(let n=0;n<h.length;n++){let f=h[n],slot=t.findSlot(f.slot);if(!slot)throw new Error("Slot not found: "+slot);let m=slot.index;for(;r!=m;)e[o++]=r++;l[r+f.offset]=r++}for(;r<n;)e[o++]=r++;for(let t=n-1;t>=0;t--)-1==l[t]&&(l[t]=e[--o])}e.setFrame(o,F(r,"time",0),l)}l.push(e)}if(map.events){let e=new r.i(map.events.length),n=0;for(let i=0;i<map.events.length;i++,n++){let r=map.events[i],l=t.findEvent(r.name);if(!l)throw new Error("Event not found: "+r.name);let o=new h.a(x.k.toSinglePrecision(F(r,"time",0)),l);o.intValue=F(r,"int",l.intValue),o.floatValue=F(r,"float",l.floatValue),o.stringValue=F(r,"string",l.stringValue),o.data.audioPath&&(o.volume=F(r,"volume",1),o.balance=F(r,"balance",0)),e.setFrame(n,o)}l.push(e)}let o=0;for(let i=0,e=l.length;i<e;i++)o=Math.max(o,l[i].getDuration());t.animations.push(new r.b(e,l,o))}}class y{constructor(e,t,n,r,l){this.mesh=e,this.skin=t,this.slotIndex=n,this.parent=r,this.inheritTimeline=l}}function C(e,t,n,r){let l=e[0],time=F(l,"time",0),o=F(l,"value",n)*r,h=0;for(let f=0;;f++){t.setFrame(f,time,o);let m=e[f+1];if(!m)return t.shrink(h),t;let d=F(m,"time",0),c=F(m,"value",n)*r;l.curve&&(h=E(l.curve,t,h,f,0,time,d,o,c,r)),time=d,o=c,l=m}}function A(e,t,n,r,l,o){let h=e[0],time=F(h,"time",0),f=F(h,n,l)*o,m=F(h,r,l)*o,d=0;for(let c=0;;c++){t.setFrame(c,time,f,m);let w=e[c+1];if(!w)return t.shrink(d),t;let k=F(w,"time",0),x=F(w,n,l)*o,S=F(w,r,l)*o,v=h.curve;v&&(d=E(v,t,d,c,0,time,k,f,x,o),d=E(v,t,d,c,1,time,k,m,S,o)),time=k,f=x,m=S,h=w}}function E(e,t,n,r,l,o,h,f,m,d){if("stepped"==e)return t.setStepped(r),n;let i=l<<2,c=e[i],w=e[i+1]*d,k=e[i+2],x=e[i+3]*d;return t.setBezier(n,r,l,o,f,c,w,k,x,h,m),n+1}function F(map,e,t){return void 0!==map[e]?map[e]:t}},430:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));class r{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(e){if(!e)throw new Error("boneName cannot be null.");let t=this.bones;for(let i=0,n=t.length;i<n;i++){let n=t[i];if(n.name==e)return n}return null}findSlot(e){if(!e)throw new Error("slotName cannot be null.");let t=this.slots;for(let i=0,n=t.length;i<n;i++){let slot=t[i];if(slot.name==e)return slot}return null}findSkin(e){if(!e)throw new Error("skinName cannot be null.");let t=this.skins;for(let i=0,n=t.length;i<n;i++){let n=t[i];if(n.name==e)return n}return null}findEvent(e){if(!e)throw new Error("eventDataName cannot be null.");let t=this.events;for(let i=0,n=t.length;i<n;i++){let n=t[i];if(n.name==e)return n}return null}findAnimation(e){if(!e)throw new Error("animationName cannot be null.");let t=this.animations;for(let i=0,n=t.length;i<n;i++){let n=t[i];if(n.name==e)return n}return null}findIkConstraint(e){if(!e)throw new Error("constraintName cannot be null.");let t=this.ikConstraints;for(let i=0,n=t.length;i<n;i++){let n=t[i];if(n.name==e)return n}return null}findTransformConstraint(e){if(!e)throw new Error("constraintName cannot be null.");let t=this.transformConstraints;for(let i=0,n=t.length;i<n;i++){let n=t[i];if(n.name==e)return n}return null}findPathConstraint(e){if(!e)throw new Error("constraintName cannot be null.");let t=this.pathConstraints;for(let i=0,n=t.length;i<n;i++){let n=t[i];if(n.name==e)return n}return null}}}}]);