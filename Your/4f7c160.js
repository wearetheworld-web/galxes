/*! For license information please see LICENSES */
(window.webpackJsonp=window.webpackJsonp||[]).push([[895,19,162,186,515,672,694,716,756,779],{2475:function(t,e,n){"use strict";function r(t,e){return e||(e=t.slice(0)),Object.freeze(Object.defineProperties(t,{raw:{value:Object.freeze(e)}}))}n.d(e,"a",(function(){return r}))},2578:function(t,e,n){t.exports=function(){"use strict";var t=1e3,e=60*t,n=60*e,r=24*n,o="visibilitychange";return{name:"countdown",data:function(){return{counting:!1,endTime:0,totalMilliseconds:0}},props:{autoStart:{type:Boolean,default:!0},emitEvents:{type:Boolean,default:!0},interval:{type:Number,default:1e3,validator:function(t){return t>=0}},now:{type:Function,default:function(){return Date.now()}},tag:{type:String,default:"span"},time:{type:Number,default:0,validator:function(t){return t>=0}},transform:{type:Function,default:function(t){return t}}},computed:{days:function(){return Math.floor(this.totalMilliseconds/r)},hours:function(){return Math.floor(this.totalMilliseconds%r/n)},minutes:function(){return Math.floor(this.totalMilliseconds%n/e)},seconds:function(){return Math.floor(this.totalMilliseconds%e/t)},milliseconds:function(){return Math.floor(this.totalMilliseconds%t)},totalDays:function(){return this.days},totalHours:function(){return Math.floor(this.totalMilliseconds/n)},totalMinutes:function(){return Math.floor(this.totalMilliseconds/e)},totalSeconds:function(){return Math.floor(this.totalMilliseconds/t)}},render:function(t){return t(this.tag,this.$scopedSlots.default?[this.$scopedSlots.default(this.transform({days:this.days,hours:this.hours,minutes:this.minutes,seconds:this.seconds,milliseconds:this.milliseconds,totalDays:this.totalDays,totalHours:this.totalHours,totalMinutes:this.totalMinutes,totalSeconds:this.totalSeconds,totalMilliseconds:this.totalMilliseconds}))]:this.$slots.default)},watch:{$props:{deep:!0,immediate:!0,handler:function(){this.totalMilliseconds=this.time,this.endTime=this.now()+this.time,this.autoStart&&this.start()}}},methods:{start:function(){this.counting||(this.counting=!0,this.emitEvents&&this.$emit("start"),"visible"===document.visibilityState&&this.continue())},continue:function(){var t=this;if(this.counting){var e=Math.min(this.totalMilliseconds,this.interval);if(e>0)if(window.requestAnimationFrame){var n,r,o=function o(f){n||(n=f),r||(r=f);var c=f-n;c>=e||c+(f-r)/2>=e?t.progress():t.requestId=requestAnimationFrame(o),r=f};this.requestId=requestAnimationFrame(o)}else this.timeoutId=setTimeout((function(){t.progress()}),e);else this.end()}},pause:function(){window.requestAnimationFrame?cancelAnimationFrame(this.requestId):clearTimeout(this.timeoutId)},progress:function(){this.counting&&(this.totalMilliseconds-=this.interval,this.emitEvents&&this.totalMilliseconds>0&&this.$emit("progress",{days:this.days,hours:this.hours,minutes:this.minutes,seconds:this.seconds,milliseconds:this.milliseconds,totalDays:this.totalDays,totalHours:this.totalHours,totalMinutes:this.totalMinutes,totalSeconds:this.totalSeconds,totalMilliseconds:this.totalMilliseconds}),this.continue())},abort:function(){this.counting&&(this.pause(),this.counting=!1,this.emitEvents&&this.$emit("abort"))},end:function(){this.counting&&(this.pause(),this.totalMilliseconds=0,this.counting=!1,this.emitEvents&&this.$emit("end"))},update:function(){this.counting&&(this.totalMilliseconds=Math.max(0,this.endTime-this.now()))},handleVisibilityChange:function(){switch(document.visibilityState){case"visible":this.update(),this.continue();break;case"hidden":this.pause()}}},mounted:function(){document.addEventListener(o,this.handleVisibilityChange)},beforeDestroy:function(){document.removeEventListener(o,this.handleVisibilityChange),this.pause()}}}()},3103:function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));var r=["1","3","4","5","8","9","10","11","12","13","14","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","49","50","52","54","56","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","81","82","83","84","85","86","87","88","89","90","91","93","94","95","96","98","99","100","105","106","107","108","109","110","111","112","113","114","116","117","121","122","123","125","131","132","170","262"]},3183:function(t,e,n){"use strict";n.d(e,"a",(function(){return U})),n.d(e,"b",(function(){return st})),n.d(e,"c",(function(){return at}));var r=n(3107);const o=BigInt(0),f=BigInt(1),c=BigInt(2),h=BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),l=Object.freeze({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),l:h,n:h,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")}),d=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),y=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),w=(BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742"),BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235")),m=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),E=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),x=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");class v{constructor(t,e,n,r){this.x=t,this.y=e,this.z=n,this.t=r}static fromAffine(p){if(!(p instanceof U))throw new TypeError("ExtendedPoint#fromAffine: expected Point");return p.equals(U.ZERO)?v.ZERO:new v(p.x,p.y,f,F(p.x*p.y))}static toAffineBatch(t){const e=function(t,p=l.P){const e=new Array(t.length),n=W(t.reduce(((t,n,i)=>n===o?t:(e[i]=t,F(t*n,p))),f),p);return t.reduceRight(((t,n,i)=>n===o?t:(e[i]=F(t*e[i],p),F(t*n,p))),n),e}(t.map((p=>p.z)));return t.map(((p,i)=>p.toAffine(e[i])))}static normalizeZ(t){return this.toAffineBatch(t).map(this.fromAffine)}equals(t){B(t);const{x:e,y:n,z:r}=this,{x:o,y:f,z:c}=t,h=F(e*c),l=F(o*r),d=F(n*c),y=F(f*r);return h===l&&d===y}negate(){return new v(F(-this.x),this.y,this.z,F(-this.t))}double(){const{x:t,y:e,z:n}=this,{a:a}=l,r=F(t*t),o=F(e*e),f=F(c*F(n*n)),h=F(a*r),d=t+e,y=F(F(d*d)-r-o),w=h+o,m=w-f,E=h-o,x=F(y*m),B=F(w*E),A=F(y*E),S=F(m*w);return new v(x,B,S,A)}add(t){B(t);const{x:e,y:n,z:r,t:f}=this,{x:h,y:l,z:d,t:y}=t,w=F((n-e)*(l+h)),m=F((n+e)*(l-h)),E=F(m-w);if(E===o)return this.double();const x=F(r*c*y),A=F(f*c*d),S=A+x,I=m+w,R=A-x,U=F(S*E),P=F(I*R),H=F(S*R),T=F(E*I);return new v(U,P,T,H)}subtract(t){return this.add(t.negate())}precomputeWindow(t){const e=1+256/t,n=[];let p=this,base=p;for(let r=0;r<e;r++){base=p,n.push(base);for(let i=1;i<2**(t-1);i++)base=base.add(p),n.push(base);p=base.double()}return n}wNAF(t,e){!e&&this.equals(v.BASE)&&(e=U.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=e&&R.get(e);r||(r=this.precomputeWindow(n),e&&1!==n&&(r=v.normalizeZ(r),R.set(e,r)));let p=v.ZERO,o=v.ZERO;const c=1+256/n,h=2**(n-1),mask=BigInt(2**n-1),l=2**n,d=BigInt(n);for(let e=0;e<c;e++){const n=e*h;let c=Number(t&mask);if(t>>=d,c>h&&(c-=l,t+=f),0===c){let t=r[n];e%2&&(t=t.negate()),o=o.add(t)}else{let t=r[n+Math.abs(c)-1];c<0&&(t=t.negate()),p=p.add(t)}}return v.normalizeZ([p,o])[0]}multiply(t,e){return this.wNAF(L(t,l.l),e)}multiplyUnsafe(t){let e=L(t,l.l,!1);const n=v.BASE,r=v.ZERO;if(e===o)return r;if(this.equals(r)||e===f)return this;if(this.equals(n))return this.wNAF(e);let p=r,c=this;for(;e>o;)e&f&&(p=p.add(c)),c=c.double(),e>>=f;return p}isSmallOrder(){return this.multiplyUnsafe(l.h).equals(v.ZERO)}isTorsionFree(){return this.multiplyUnsafe(l.l).equals(v.ZERO)}toAffine(t=W(this.z)){const{x:e,y:n,z:r}=this,o=F(e*t),c=F(n*t);if(F(r*t)!==f)throw new Error("invZ was invalid");return new U(o,c)}fromRistrettoBytes(){S()}toRistrettoBytes(){S()}fromRistrettoHash(){S()}}function B(t){if(!(t instanceof v))throw new TypeError("ExtendedPoint expected")}function A(t){if(!(t instanceof I))throw new TypeError("RistrettoPoint expected")}function S(){throw new Error("Legacy method: switch to RistrettoPoint")}v.BASE=new v(l.Gx,l.Gy,f,F(l.Gx*l.Gy)),v.ZERO=new v(o,f,f,o);class I{constructor(t){this.ep=t}static calcElligatorRistrettoMap(t){const{d:e}=l,n=F(y*t*t),r=F((n+f)*E);let o=BigInt(-1);const c=F((o-e*n)*F(n+e));let{isValid:h,value:s}=C(r,c),d=F(s*t);N(d)||(d=F(-d)),h||(s=d),h||(o=n);const m=F(o*(n-f)*x-c),B=s*s,A=F((s+s)*c),S=F(m*w),I=F(f-B),R=F(f+B);return new v(F(A*R),F(I*S),F(S*R),F(A*I))}static hashToCurve(t){const e=_((t=j(t,64)).slice(0,32)),n=this.calcElligatorRistrettoMap(e),r=_(t.slice(32,64)),o=this.calcElligatorRistrettoMap(r);return new I(n.add(o))}static fromHex(t){t=j(t,32);const{a:a,d:e}=l,n="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",s=_(t);if(!function(t,e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}(k(s),t)||N(s))throw new Error(n);const r=F(s*s),c=F(f+a*r),h=F(f-a*r),d=F(c*c),y=F(h*h),w=F(a*e*d-y),{isValid:m,value:E}=G(F(w*y)),x=F(E*h),B=F(E*x*w);let A=F((s+s)*x);N(A)&&(A=F(-A));const S=F(c*B),R=F(A*S);if(!m||N(R)||S===o)throw new Error(n);return new I(new v(A,S,f,R))}toRawBytes(){let{x:t,y:e,z:n,t:r}=this.ep;const o=F(F(n+e)*F(n-e)),f=F(t*e),c=F(f*f),{value:h}=G(F(o*c)),l=F(h*o),d=F(h*f),w=F(l*d*r);let E;if(N(r*w)){let n=F(e*y),r=F(t*y);t=n,e=r,E=F(l*m)}else E=d;N(t*w)&&(e=F(-e));let s=F((n-e)*E);return N(s)&&(s=F(-s)),k(s)}toHex(){return M(this.toRawBytes())}toString(){return this.toHex()}equals(t){A(t);const a=this.ep,b=t.ep,e=F(a.x*b.y)===F(a.y*b.x),n=F(a.y*b.y)===F(a.x*b.x);return e||n}add(t){return A(t),new I(this.ep.add(t.ep))}subtract(t){return A(t),new I(this.ep.subtract(t.ep))}multiply(t){return new I(this.ep.multiply(t))}multiplyUnsafe(t){return new I(this.ep.multiplyUnsafe(t))}}I.BASE=new I(v.BASE),I.ZERO=new I(v.ZERO);const R=new WeakMap;class U{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,R.delete(this)}static fromHex(t,e=!0){const{d:n,P:r}=l,o=(t=j(t,32)).slice();o[31]=-129&t[31];const c=Z(o);if(e&&c>=r)throw new Error("Expected 0 < hex < P");if(!e&&c>=d)throw new Error("Expected 0 < hex < 2**256");const h=F(c*c),u=F(h-f),y=F(n*h+f);let{isValid:w,value:m}=C(u,y);if(!w)throw new Error("Point.fromHex: invalid y coordinate");const E=(m&f)===f;return 0!=(128&t[31])!==E&&(m=F(-m)),new U(m,c)}static async fromPrivateKey(t){return(await et(t)).point}toRawBytes(){const t=k(this.y);return t[31]|=this.x&f?128:0,t}toHex(){return M(this.toRawBytes())}toX25519(){const{y:t}=this;return k(F((f+t)*W(f-t)))}isTorsionFree(){return v.fromAffine(this).isTorsionFree()}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new U(F(-this.x),this.y)}add(t){return v.fromAffine(this).add(v.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return v.fromAffine(this).multiply(t,this).toAffine()}}U.BASE=new U(l.Gx,l.Gy),U.ZERO=new U(o,f);class P{constructor(t,s){this.r=t,this.s=s,this.assertValidity()}static fromHex(t){const e=j(t,64),n=U.fromHex(e.slice(0,32),!1),s=Z(e.slice(32,64));return new P(n,s)}assertValidity(){const{r:t,s:s}=this;if(!(t instanceof U))throw new Error("Expected Point instance");return L(s,l.l,!1),this}toRawBytes(){const t=new Uint8Array(64);return t.set(this.r.toRawBytes()),t.set(k(this.s),32),t}toHex(){return M(this.toRawBytes())}}function H(...t){if(!t.every((a=>a instanceof Uint8Array)))throw new Error("Expected Uint8Array list");if(1===t.length)return t[0];const e=t.reduce(((a,t)=>a+t.length),0),n=new Uint8Array(e);for(let i=0,e=0;i<t.length;i++){const r=t[i];n.set(r,e),e+=r.length}return n}const T=Array.from({length:256},((t,i)=>i.toString(16).padStart(2,"0")));function M(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected");let e="";for(let i=0;i<t.length;i++)e+=T[t[i]];return e}function z(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const e=new Uint8Array(t.length/2);for(let i=0;i<e.length;i++){const n=2*i,r=t.slice(n,n+2),o=Number.parseInt(r,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[i]=o}return e}function O(t){return z(t.toString(16).padStart(64,"0"))}function k(t){return O(t).reverse()}function N(t){return(F(t)&f)===f}function Z(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");return BigInt("0x"+M(Uint8Array.from(t).reverse()))}const $=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function _(t){return F(Z(t)&$)}function F(a,b=l.P){const t=a%b;return t>=o?t:b+t}function W(t,e=l.P){if(t===o||e<=o)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let a=F(t,e),b=e,n=o,r=f,u=f,c=o;for(;a!==o;){const q=b/a,t=b%a,e=n-u*q,o=r-c*q;b=a,a=t,n=u,r=c,u=e,c=o}if(b!==f)throw new Error("invert: does not exist");return F(n,e)}function D(t,e){const{P:n}=l;let r=t;for(;e-- >o;)r*=r,r%=n;return r}function V(t){const{P:e}=l,n=BigInt(5),r=BigInt(10),o=BigInt(20),h=BigInt(40),d=BigInt(80),y=t*t%e*t%e,w=D(y,c)*y%e,m=D(w,f)*t%e,E=D(m,n)*m%e,x=D(E,r)*E%e,v=D(x,o)*x%e,B=D(v,h)*v%e,A=D(B,d)*B%e,S=D(A,d)*B%e,I=D(S,r)*E%e;return{pow_p_5_8:D(I,c)*t%e,b2:y}}function C(u,t){const e=F(t*t*t),n=F(e*e*t);let r=F(u*e*V(u*n).pow_p_5_8);const o=F(t*r*r),f=r,c=F(r*y),h=o===u,l=o===F(-u),d=o===F(-u*y);return h&&(r=f),(l||d)&&(r=c),N(r)&&(r=F(-r)),{isValid:h||l,value:r}}function G(t){return C(f,t)}function K(t){return F(Z(t),l.l)}function j(t,e){const n=t instanceof Uint8Array?Uint8Array.from(t):z(t);if("number"==typeof e&&n.length!==e)throw new Error(`Expected ${e} bytes`);return n}function L(t,e,n=!0){if(!e)throw new TypeError("Specify max value");if("number"==typeof t&&Number.isSafeInteger(t)&&(t=BigInt(t)),"bigint"==typeof t&&t<e)if(n){if(o<t)return t}else if(o<=t)return t;throw new TypeError("Expected valid scalar: 0 < scalar < max")}function J(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}function X(t){if(32!==(t="bigint"==typeof t||"number"==typeof t?O(L(t,d)):j(t)).length)throw new Error("Expected 32 bytes");return t}function Y(t){const head=J(t.slice(0,32)),e=t.slice(32,64),n=K(head),r=U.BASE.multiply(n),o=r.toRawBytes();return{head:head,prefix:e,scalar:n,point:r,pointBytes:o}}let Q;function tt(...t){if("function"!=typeof Q)throw new Error("utils.sha512Sync must be set to use sync methods");return Q(...t)}async function et(t){return Y(await at.sha512(X(t)))}function nt(t){return Y(tt(X(t)))}function it(t,e,n){e=j(e),n instanceof U||(n=U.fromHex(n,!1));const{r:r,s:s}=t instanceof P?t.assertValidity():P.fromHex(t);return{r:r,s:s,SB:v.BASE.multiplyUnsafe(s),pub:n,msg:e}}function ot(t,e,n,r){const o=K(r),f=v.fromAffine(t).multiplyUnsafe(o);return v.fromAffine(e).add(f).subtract(n).multiplyUnsafe(l.h).equals(v.ZERO)}const st={getExtendedPublicKey:nt,getPublicKey:function(t){return nt(t).pointBytes},sign:function(t,e){t=j(t);const{prefix:n,scalar:r,pointBytes:o}=nt(e),f=K(tt(n,t)),c=U.BASE.multiply(f),s=F(f+K(tt(c.toRawBytes(),o,t))*r,l.l);return new P(c,s).toRawBytes()},verify:function(t,e,n){const{r:r,SB:o,msg:f,pub:c}=it(t,e,n),h=tt(r.toRawBytes(),c.toRawBytes(),f);return ot(c,r,o,h)}};U.BASE._setWindowSize(8);const ft={node:r,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},at={bytesToHex:M,hexToBytes:z,concatBytes:H,getExtendedPublicKey:et,mod:F,invert:W,TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],hashToPrivateScalar:t=>{if((t=j(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return F(Z(t),l.l-f)+f},randomBytes:(t=32)=>{if(ft.web)return ft.web.getRandomValues(new Uint8Array(t));if(ft.node){const{randomBytes:e}=ft.node;return new Uint8Array(e(t).buffer)}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>at.randomBytes(32),sha512:async(...t)=>{const e=H(...t);if(ft.web){const t=await ft.web.subtle.digest("SHA-512",e.buffer);return new Uint8Array(t)}if(ft.node)return Uint8Array.from(ft.node.createHash("sha512").update(e).digest());throw new Error("The environment doesn't have sha512 function")},precompute(t=8,e=U.BASE){const n=e.equals(U.BASE)?e:new U(e.x,e.y);return n._setWindowSize(t),n.multiply(c),n},sha512Sync:void 0};Object.defineProperties(at,{sha512Sync:{configurable:!1,get:()=>Q,set(t){Q||(Q=t)}}})},3188:function(t,e,n){"use strict";n.d(e,"a",(function(){return tt})),n.d(e,"b",(function(){return ft})),n.d(e,"c",(function(){return ut}));var r=n(3108);const o=BigInt(0),f=BigInt(1),c=BigInt(2),h=BigInt(3),l=BigInt(8),d=Object.freeze({a:o,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:f,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});function y(t){const{a:a,b:b}=d,e=$(t*t),n=$(e*t);return $(n+a*t+b)}const w=d.a===o;class m extends Error{constructor(t){super(t)}}class E{constructor(t,e,n){this.x=t,this.y=e,this.z=n}static fromAffine(p){if(!(p instanceof v))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new E(p.x,p.y,f)}static toAffineBatch(t){const e=function(t,p=d.P){const e=new Array(t.length),n=F(t.reduce(((t,n,i)=>n===o?t:(e[i]=t,$(t*n,p))),f),p);return t.reduceRight(((t,n,i)=>n===o?t:(e[i]=$(t*e[i],p),$(t*n,p))),n),e}(t.map((p=>p.z)));return t.map(((p,i)=>p.toAffine(e[i])))}static normalizeZ(t){return E.toAffineBatch(t).map(E.fromAffine)}equals(t){if(!(t instanceof E))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:o,y:f,z:c}=t,h=$(r*r),l=$(c*c),d=$(e*l),y=$(o*h),w=$($(n*c)*l),m=$($(f*r)*h);return d===y&&w===m}negate(){return new E(this.x,$(-this.y),this.z)}double(){const{x:t,y:e,z:n}=this,r=$(t*t),o=$(e*e),f=$(o*o),d=t+o,y=$(c*($(d*d)-r-f)),w=$(h*r),m=$(w*w),x=$(m-c*y),v=$(w*(y-x)-l*f),B=$(c*e*n);return new E(x,v,B)}add(t){if(!(t instanceof E))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:f,y:h,z:l}=t;if(f===o||h===o)return this;if(e===o||n===o)return t;const d=$(r*r),y=$(l*l),w=$(e*y),m=$(f*d),x=$($(n*l)*y),v=$($(h*r)*d),B=$(m-w),A=$(v-x);if(B===o)return A===o?this.double():E.ZERO;const S=$(B*B),I=$(B*S),R=$(w*S),U=$(A*A-I-c*R),P=$(A*(R-U)-x*I),H=$(r*l*B);return new E(U,P,H)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=E.ZERO;if("bigint"==typeof t&&t===o)return e;let n=Z(t);if(n===f)return this;if(!w){let p=e,t=this;for(;n>o;)n&f&&(p=p.add(t)),t=t.double(),n>>=f;return p}let{k1neg:r,k1:c,k2neg:h,k2:l}=V(n),y=e,m=e,x=this;for(;c>o||l>o;)c&f&&(y=y.add(x)),l&f&&(m=m.add(x)),x=x.double(),c>>=f,l>>=f;return r&&(y=y.negate()),h&&(m=m.negate()),m=new E($(m.x*d.beta),m.y,m.z),y.add(m)}precomputeWindow(t){const e=w?128/t+1:256/t+1,n=[];let p=this,base=p;for(let r=0;r<e;r++){base=p,n.push(base);for(let i=1;i<2**(t-1);i++)base=base.add(p),n.push(base);p=base.double()}return n}wNAF(t,e){!e&&this.equals(E.BASE)&&(e=v.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=e&&x.get(e);r||(r=this.precomputeWindow(n),e&&1!==n&&(r=E.normalizeZ(r),x.set(e,r)));let p=E.ZERO,o=E.ZERO;const c=1+(w?128/n:256/n),h=2**(n-1),mask=BigInt(2**n-1),l=2**n,d=BigInt(n);for(let e=0;e<c;e++){const n=e*h;let c=Number(t&mask);if(t>>=d,c>h&&(c-=l,t+=f),0===c){let t=r[n];e%2&&(t=t.negate()),o=o.add(t)}else{let t=r[n+Math.abs(c)-1];c<0&&(t=t.negate()),p=p.add(t)}}return{p:p,f:o}}multiply(t,e){let n,r,o=Z(t);if(w){const{k1neg:t,k1:f,k2neg:c,k2:h}=V(o);let{p:l,f:y}=this.wNAF(f,e),{p:w,f:m}=this.wNAF(h,e);t&&(l=l.negate()),c&&(w=w.negate()),w=new E($(w.x*d.beta),w.y,w.z),n=l.add(w),r=y.add(m)}else{const{p:p,f:t}=this.wNAF(o,e);n=p,r=t}return E.normalizeZ([n,r])[0]}toAffine(t=F(this.z)){const{x:e,y:n,z:r}=this,o=t,c=$(o*o),h=$(c*o),l=$(e*c),d=$(n*h);if($(r*o)!==f)throw new Error("invZ was invalid");return new v(l,d)}}E.BASE=new E(d.Gx,d.Gy,f),E.ZERO=new E(o,f,o);const x=new WeakMap;class v{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,x.delete(this)}hasEvenY(){return this.y%c===o}static fromCompressedHex(t){const e=32===t.length,n=k(e?t:t.subarray(1));if(!J(n))throw new Error("Point is not on curve");let r=function(t){const{P:e}=d,n=BigInt(6),r=BigInt(11),o=BigInt(22),f=BigInt(23),l=BigInt(44),y=BigInt(88),w=t*t*t%e,m=w*w*t%e,E=_(m,h)*m%e,x=_(E,h)*m%e,v=_(x,c)*w%e,B=_(v,r)*v%e,A=_(B,o)*B%e,S=_(A,l)*A%e,I=_(S,y)*S%e,R=_(I,l)*A%e,U=_(R,h)*m%e,P=_(U,f)*B%e,H=_(P,n)*w%e;return _(H,c)}(y(n));const o=(r&f)===f;if(e)o&&(r=$(-r));else{1==(1&t[0])!==o&&(r=$(-r))}const l=new v(n,r);return l.assertValidity(),l}static fromUncompressedHex(t){const e=k(t.subarray(1,33)),n=k(t.subarray(33,65)),r=new v(e,n);return r.assertValidity(),r}static fromHex(t){const e=N(t),n=e.length,header=e[0];if(32===n||33===n&&(2===header||3===header))return this.fromCompressedHex(e);if(65===n&&4===header)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${n}`)}static fromPrivateKey(t){return v.BASE.multiply(Y(t))}static fromSignature(t,e,n){const r=C(t=N(t)),{r:o,s:s}=Q(e);if(0!==n&&1!==n)throw new Error("Cannot recover signature: invalid recovery bit");const f=1&n?"03":"02",c=v.fromHex(f+H(o)),{n:h}=d,l=F(o,h),y=$(-r*l,h),w=$(s*l,h),m=v.BASE.multiplyAndAddUnsafe(c,y,w);if(!m)throw new Error("Cannot recover signature: point at infinify");return m.assertValidity(),m}toRawBytes(t=!1){return O(this.toHex(t))}toHex(t=!1){const e=H(this.x);if(t){return`${this.hasEvenY()?"02":"03"}${e}`}return`04${e}${H(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:n}=this;if(!J(e)||!J(n))throw new Error(t);const r=$(n*n);if($(r-y(e))!==o)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new v(this.x,$(-this.y))}double(){return E.fromAffine(this).double().toAffine()}add(t){return E.fromAffine(this).add(E.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return E.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,a,b){const e=E.fromAffine(this),n=a===o||a===f||this!==v.BASE?e.multiplyUnsafe(a):e.multiply(a),r=E.fromAffine(t).multiplyUnsafe(b),c=n.add(r);return c.equals(E.ZERO)?void 0:c.toAffine()}}function B(s){return Number.parseInt(s[0],16)>=8?"00"+s:s}function A(data){if(data.length<2||2!==data[0])throw new Error(`Invalid signature integer tag: ${U(data)}`);const t=data[1],e=data.subarray(2,t+2);if(!t||e.length!==t)throw new Error("Invalid signature integer: wrong length");if(0===e[0]&&e[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:k(e),left:data.subarray(t+2)}}v.BASE=new v(d.Gx,d.Gy),v.ZERO=new v(o,o);class S{constructor(t,s){this.r=t,this.s=s,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,n="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${n}: Expected string or Uint8Array`);const r=e?U(t):t;if(128!==r.length)throw new Error(`${n}: Expected 64-byte hex`);return new S(z(r.slice(0,64)),z(r.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:n,s:s}=function(data){if(data.length<2||48!=data[0])throw new Error(`Invalid signature tag: ${U(data)}`);if(data[1]!==data.length-2)throw new Error("Invalid signature: incorrect length");const{data:t,left:e}=A(data.subarray(2)),{data:s,left:n}=A(e);if(n.length)throw new Error(`Invalid signature: left bytes after parsing: ${U(n)}`);return{r:t,s:s}}(e?t:O(t));return new S(n,s)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:s}=this;if(!L(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!L(s))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=d.n>>f;return this.s>t}normalizeS(){return this.hasHighS()?new S(this.r,d.n-this.s):this}toDERRawBytes(t=!1){return O(this.toDERHex(t))}toDERHex(t=!1){const e=B(M(this.s));if(t)return e;const n=B(M(this.r)),r=M(n.length/2),o=M(e.length/2);return`30${M(n.length/2+e.length/2+4)}02${r}${n}02${o}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return O(this.toCompactHex())}toCompactHex(){return H(this.r)+H(this.s)}}function I(...t){if(!t.every((b=>b instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((a,t)=>a+t.length),0),n=new Uint8Array(e);for(let i=0,e=0;i<t.length;i++){const r=t[i];n.set(r,e),e+=r.length}return n}const R=Array.from({length:256},((t,i)=>i.toString(16).padStart(2,"0")));function U(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let i=0;i<t.length;i++)e+=R[t[i]];return e}const P=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function H(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(o<=t&&t<P))throw new Error("Expected number < 2^256");return t.toString(16).padStart(64,"0")}function T(t){const b=O(H(t));if(32!==b.length)throw new Error("Error: expected 32 bytes");return b}function M(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function z(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function O(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let i=0;i<e.length;i++){const n=2*i,r=t.slice(n,n+2),o=Number.parseInt(r,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[i]=o}return e}function k(t){return z(U(t))}function N(t){return t instanceof Uint8Array?Uint8Array.from(t):O(t)}function Z(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&L(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function $(a,b=d.P){const t=a%b;return t>=o?t:b+t}function _(t,e){const{P:n}=d;let r=t;for(;e-- >o;)r*=r,r%=n;return r}function F(t,e=d.P){if(t===o||e<=o)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let a=$(t,e),b=e,n=o,r=f,u=f,c=o;for(;a!==o;){const q=b/a,t=b%a,e=n-u*q,o=r-c*q;b=a,a=t,n=u,r=c,u=e,c=o}if(b!==f)throw new Error("invert: does not exist");return $(n,e)}const W=(a,b)=>(a+b/c)/b,D={a1:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),b1:-f*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),a2:BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),b2:BigInt("0x3086d221a7d46bcde86c90e49284eb15"),POW_2_128:BigInt("0x100000000000000000000000000000000")};function V(t){const{n:e}=d,{a1:n,b1:r,a2:o,b2:f,POW_2_128:c}=D,h=W(f*t,e),l=W(-r*t,e);let y=$(t-h*n-l*o,e),w=$(-h*r-l*f,e);const m=y>c,E=w>c;if(m&&(y=e-y),E&&(w=e-w),y>c||w>c)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:m,k1:y,k2neg:E,k2:w}}function C(t){const{n:e}=d,n=8*t.length-256;let r=k(t);return n>0&&(r>>=BigInt(n)),r>=e&&(r-=e),r}let G,K;class j{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return ut.hmacSha256(this.k,...t)}hmacSync(...t){return K(this.k,...t)}checkSync(){if("function"!=typeof K)throw new m("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.checkSync(),this.incr(),this.v=this.hmacSync(this.v),this.v}}function L(t){return o<t&&t<d.n}function J(t){return o<t&&t<d.P}function X(t,e,n){const r=k(t);if(!L(r))return;const{n:c}=d,q=v.BASE.multiply(r),h=$(q.x,c);if(h===o)return;const s=$(F(r,c)*$(e+n*h,c),c);if(s===o)return;const l=new S(h,s);return{sig:l,recovery:(q.x===l.r?0:2)|Number(q.y&f)}}function Y(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=z(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(32!==t.length)throw new Error("Expected 32 bytes of private key");e=k(t)}if(!L(e))throw new Error("Expected private key: 0 < key < n");return e}function Q(t){if(t instanceof S)return t.assertValidity(),t;try{return S.fromDER(t)}catch(e){return S.fromCompact(t)}}function tt(t,e=!1){return v.fromPrivateKey(t).toRawBytes(e)}function et(t){return k(t.length>32?t.slice(0,32):t)}function nt(t){const e=et(t),n=$(e,d.n);return it(n<o?e:n)}function it(t){return T(t)}function ot(t,e,n){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const h1=N(t),r=Y(e),o=[it(r),nt(h1)];if(null!=n){!0===n&&(n=ut.randomBytes(32));const t=N(n);if(32!==t.length)throw new Error("sign: Expected 32 bytes of extra data");o.push(t)}return{seed:I(...o),m:et(h1),d:r}}function st(t,e){let{sig:n,recovery:r}=t;const{canonical:o,der:f,recovered:c}=Object.assign({canonical:!0,der:!0},e);o&&n.hasHighS()&&(n=n.normalizeS(),r^=1);const h=f?n.toDERRawBytes():n.toCompactRawBytes();return c?[h,r]:h}function ft(t,e,n={}){const{seed:r,m:o,d:f}=ot(t,e,n.extraEntropy);let c;const h=new j;for(h.reseedSync(r);!(c=X(h.generateSync(),o,f));)h.reseedSync();return st(c,n)}v.BASE._setWindowSize(8);const at={node:r,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},ct={},ut={bytesToHex:U,hexToBytes:O,concatBytes:I,mod:$,invert:F,isValidPrivateKey(t){try{return Y(t),!0}catch(t){return!1}},_bigintTo32Bytes:T,_normalizePrivateKey:Y,hashToPrivateKey:t=>{if((t=N(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return T($(k(t),d.n-f)+f)},randomBytes:(t=32)=>{if(at.web)return at.web.getRandomValues(new Uint8Array(t));if(at.node){const{randomBytes:e}=at.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>ut.hashToPrivateKey(ut.randomBytes(40)),sha256:async(...t)=>{if(at.web){const e=await at.web.subtle.digest("SHA-256",I(...t));return new Uint8Array(e)}if(at.node){const{createHash:e}=at.node,n=e("sha256");return t.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(at.web){const n=await at.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=I(...e),o=await at.web.subtle.sign("HMAC",n,r);return new Uint8Array(o)}if(at.node){const{createHmac:n}=at.node,r=n("sha256",t);return e.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let n=ct[t];if(void 0===n){const e=await ut.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=I(e,e),ct[t]=n}return ut.sha256(n,...e)},taggedHashSync:(t,...e)=>{if("function"!=typeof G)throw new m("sha256Sync is undefined, you need to set it");let n=ct[t];if(void 0===n){const e=G(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=I(e,e),ct[t]=n}return G(n,...e)},precompute(t=8,e=v.BASE){const n=e===v.BASE?e:new v(e.x,e.y);return n._setWindowSize(t),n.multiply(h),n}};Object.defineProperties(ut,{sha256Sync:{configurable:!1,get:()=>G,set(t){G||(G=t)}},hmacSha256Sync:{configurable:!1,get:()=>K,set(t){K||(K=t)}}})},3380:function(t,e,n){"use strict";n.d(e,"a",(function(){return r}));var r=function(link){return link.indexOf("opensea.io")>0?{icon:"https://storage.googleapis.com/opensea-static/Logomark/Logomark-Blue.svg",name:"OpenSea"}:link.indexOf("fangible.com")>0?{icon:"https://d257b89266utxb.cloudfront.net/galaxy/images/logo/Fangible.jpg",name:"fangible"}:link.indexOf("treasureland.market")>0?{icon:"https://d257b89266utxb.cloudfront.net/galaxy/images/logo/TL.png",name:"treasureland"}:link.indexOf("nftrade.com")>0?{icon:n(3275),name:"nftrade"}:{}}}}]);