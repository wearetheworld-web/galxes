(window.webpackJsonp=window.webpackJsonp||[]).push([[886,18,125,154,179,664,686,708,747,770,1086],{3180:function(e,t,r){"use strict";r.d(t,"a",(function(){return bt})),r.d(t,"b",(function(){return L})),r.d(t,"c",(function(){return ie})),r.d(t,"d",(function(){return pe})),r.d(t,"e",(function(){return ee})),r.d(t,"f",(function(){return Z})),r.d(t,"g",(function(){return se}));var n=r(20),o=r(3181),c=r(3183),d=r(45),l=r.n(d),h=r(63),j=r.n(h),y=r(3184),m=r(570),O=r(2867),k=r(3185),f=r(0),S=(r(927),r(928),r(3186)),I=r(3187),w=r(3188);c.c.sha512Sync=(...e)=>Object(o.sha512)(c.c.concatBytes(...e));c.c.randomPrivateKey;const P=()=>{const e=c.c.randomPrivateKey(),t=v(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),{publicKey:t,secretKey:r}},v=c.b.getPublicKey;function A(e){try{return c.a.fromHex(e,!0),!0}catch{return!1}}const x=(e,t)=>c.b.sign(e,t.slice(0,32)),W=c.b.verify,B=e=>n.Buffer.isBuffer(e)?e:e instanceof Uint8Array?n.Buffer.from(e.buffer,e.byteOffset,e.byteLength):n.Buffer.from(e);class z{constructor(e){Object.assign(this,e)}encode(){return n.Buffer.from(Object(m.serialize)(K,this))}static decode(data){return Object(m.deserialize)(K,this,data)}static decodeUnchecked(data){return Object(m.deserializeUnchecked)(K,this,data)}}const K=new Map;let E;const T=32;let C=1;E=Symbol.toStringTag;class L extends z{constructor(e){if(super({}),this._bn=void 0,function(e){return void 0!==e._bn}(e))this._bn=e._bn;else{if("string"==typeof e){const t=j.a.decode(e);if(t.length!=T)throw new Error("Invalid public key input");this._bn=new l.a(t)}else this._bn=new l.a(e);if(this._bn.byteLength()>T)throw new Error("Invalid public key input")}}static unique(){const e=new L(C);return C+=1,new L(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return j.a.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const b=this._bn.toArrayLike(n.Buffer);if(b.length===T)return b;const e=n.Buffer.alloc(32);return b.copy(e,32-b.length),e}get[E](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const o=n.Buffer.concat([e.toBuffer(),n.Buffer.from(t),r.toBuffer()]),c=Object(y.sha256)(o);return new L(c)}static createProgramAddressSync(e,t){let r=n.Buffer.alloc(0);e.forEach((function(e){if(e.length>32)throw new TypeError("Max seed length exceeded");r=n.Buffer.concat([r,B(e)])})),r=n.Buffer.concat([r,t.toBuffer(),n.Buffer.from("ProgramDerivedAddress")]);const o=Object(y.sha256)(r);if(A(o))throw new Error("Invalid seeds, address must fall off the curve");return new L(o)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let address,r=255;for(;0!=r;){try{const o=e.concat(n.Buffer.from([r]));address=this.createProgramAddressSync(o,t)}catch(e){if(e instanceof TypeError)throw e;r--;continue}return[address,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){return A(new L(e).toBytes())}}L.default=new L("11111111111111111111111111111111"),K.set(L,{kind:"struct",fields:[["_bn","u256"]]});new L("BPFLoader1111111111111111111111111111111111");const _=1232;class N extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(N.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class R extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(R.prototype,"name",{value:"TransactionExpiredTimeoutError"});class M extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(M.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class D{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const t=new Map;this.keySegments().flat().forEach(((e,r)=>{t.set(e.toBase58(),r)}));const r=e=>{const r=t.get(e.toBase58());if(void 0===r)throw new Error("Encountered an unknown instruction account key during compilation");return r};return e.map((e=>({programIdIndex:r(e.programId),accountKeyIndexes:e.keys.map((meta=>r(meta.pubkey))),data:e.data})))}}const U=(e="publicKey")=>O.blob(32,e),V=(e="string")=>{const t=O.struct([O.u32("length"),O.u32("lengthPadding"),O.blob(O.offset(O.u32(),-8),"chars")],e),r=t.decode.bind(t),o=t.encode.bind(t),c=t;return c.decode=(b,e)=>r(b,e).chars.toString(),c.encode=(e,b,t)=>{const data={chars:n.Buffer.from(e,"utf8")};return o(data,b,t)},c.alloc=e=>O.u32().span+O.u32().span+n.Buffer.from(e,"utf8").length,c};function H(e,t){const r=e=>{if(e.span>=0)return e.span;if("function"==typeof e.alloc)return e.alloc(t[e.property]);if("count"in e&&"elementLayout"in e){const n=t[e.property];if(Array.isArray(n))return n.length*r(e.elementLayout)}else if("fields"in e)return H({layout:e},t[e.property]);return 0};let n=0;return e.layout.fields.forEach((e=>{n+=r(e)})),n}function F(e){let t=0,r=0;for(;;){let n=e.shift();if(t|=(127&n)<<7*r,r+=1,0==(128&n))break}return t}function $(e,t){let r=t;for(;;){let t=127&r;if(r>>=7,0==r){e.push(t);break}t|=128,e.push(t)}}function J(e,t){if(!e)throw new Error(t||"Assertion failed")}class G{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,n=e=>{const address=e.toBase58();let t=r.get(address);return void 0===t&&(t={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(address,t)),t},o=n(t);o.isSigner=!0,o.isWritable=!0;for(const t of e){n(t.programId).isInvoked=!0;for(const e of t.keys){const t=n(e.pubkey);t.isSigner||(t.isSigner=e.isSigner),t.isWritable||(t.isWritable=e.isWritable)}}return new G(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];J(e.length<=256,"Max static account keys length exceeded");const t=e.filter((([,meta])=>meta.isSigner&&meta.isWritable)),r=e.filter((([,meta])=>meta.isSigner&&!meta.isWritable)),n=e.filter((([,meta])=>!meta.isSigner&&meta.isWritable)),o=e.filter((([,meta])=>!meta.isSigner&&!meta.isWritable)),header={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{J(t.length>0,"Expected at least one writable signer key");const[e]=t[0];J(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[header,[...t.map((([address])=>new L(address))),...r.map((([address])=>new L(address))),...n.map((([address])=>new L(address))),...o.map((([address])=>new L(address)))]]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&e.isWritable)),[n,o]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&!e.isWritable));if(0!==t.length||0!==n.length)return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[address,o]of this.keyMetaMap.entries())if(t(o)){const t=new L(address),o=e.findIndex((e=>e.equals(t)));o>=0&&(J(o<256,"Max lookup table index exceeded"),r.push(o),n.push(t),this.keyMetaMap.delete(address))}return[r,n]}}class X{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map((e=>new L(e))),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach((e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:j.a.decode(e.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new D(this.staticAccountKeys)}static compile(e){const t=G.compile(e.instructions,e.payerKey),[header,r]=t.getMessageComponents(),n=new D(r).compileInstructions(e.instructions).map((e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:j.a.encode(e.data)})));return new X({header:header,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:n})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){return e-t<this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts}return e<t-this.header.numReadonlySignedAccounts}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((e,t)=>!this.isProgramId(t)))}serialize(){const e=this.accountKeys.length;let t=[];$(t,e);const r=this.instructions.map((e=>{const{accounts:t,programIdIndex:r}=e,data=Array.from(j.a.decode(e.data));let o=[];$(o,t.length);let c=[];return $(c,data.length),{programIdIndex:r,keyIndicesCount:n.Buffer.from(o),keyIndices:t,dataLength:n.Buffer.from(c),data:data}}));let o=[];$(o,r.length);let c=n.Buffer.alloc(_);n.Buffer.from(o).copy(c);let d=o.length;r.forEach((e=>{const t=O.struct([O.u8("programIdIndex"),O.blob(e.keyIndicesCount.length,"keyIndicesCount"),O.seq(O.u8("keyIndex"),e.keyIndices.length,"keyIndices"),O.blob(e.dataLength.length,"dataLength"),O.seq(O.u8("userdatum"),e.data.length,"data")]).encode(e,c,d);d+=t})),c=c.slice(0,d);const l=O.struct([O.blob(1,"numRequiredSignatures"),O.blob(1,"numReadonlySignedAccounts"),O.blob(1,"numReadonlyUnsignedAccounts"),O.blob(t.length,"keyCount"),O.seq(U("key"),e,"keys"),U("recentBlockhash")]),h={numRequiredSignatures:n.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:n.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:n.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:n.Buffer.from(t),keys:this.accountKeys.map((e=>B(e.toBytes()))),recentBlockhash:j.a.decode(this.recentBlockhash)};let y=n.Buffer.alloc(2048);const m=l.encode(h,y);return c.copy(y,m),y.slice(0,m+c.length)}static from(e){let t=[...e];const r=t.shift();if(r!==(127&r))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const o=t.shift(),c=t.shift(),d=F(t);let l=[];for(let i=0;i<d;i++){const e=t.slice(0,T);t=t.slice(T),l.push(new L(n.Buffer.from(e)))}const h=t.slice(0,T);t=t.slice(T);const y=F(t);let m=[];for(let i=0;i<y;i++){const e=t.shift(),r=F(t),o=t.slice(0,r);t=t.slice(r);const c=F(t),d=t.slice(0,c),data=j.a.encode(n.Buffer.from(d));t=t.slice(c),m.push({programIdIndex:e,accounts:o,data:data})}const O={header:{numRequiredSignatures:r,numReadonlySignedAccounts:o,numReadonlyUnsignedAccounts:c},recentBlockhash:j.a.encode(n.Buffer.from(h)),accountKeys:l,instructions:m};return new X(O)}}let Q;!function(e){e[e.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",e[e.PROCESSED=1]="PROCESSED",e[e.TIMED_OUT=2]="TIMED_OUT",e[e.NONCE_INVALID=3]="NONCE_INVALID"}(Q||(Q={}));const Y=n.Buffer.alloc(64).fill(0);class Z{constructor(e){this.keys=void 0,this.programId=void 0,this.data=n.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map((({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r}))),programId:this.programId.toJSON(),data:[...this.data]}}}class ee{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((e=>e.toJSON())),signers:this.signatures.map((({publicKey:e})=>e.toJSON()))}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach((e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new Z(e))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t,r;if(this.nonceInfo?(e=this.nonceInfo.nonce,t=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(t.length<1&&console.warn("No instructions provided"),this.feePayer)r=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");r=this.signatures[0].publicKey}for(let i=0;i<t.length;i++)if(void 0===t[i].programId)throw new Error(`Transaction instruction index ${i} has undefined program id`);const n=[],o=[];t.forEach((e=>{e.keys.forEach((e=>{o.push({...e})}));const t=e.programId.toString();n.includes(t)||n.push(t)})),n.forEach((e=>{o.push({pubkey:new L(e),isSigner:!1,isWritable:!1})}));const c=[];o.forEach((e=>{const t=e.pubkey.toString(),r=c.findIndex((e=>e.pubkey.toString()===t));r>-1?(c[r].isWritable=c[r].isWritable||e.isWritable,c[r].isSigner=c[r].isSigner||e.isSigner):c.push(e)})),c.sort((function(e,t){return e.isSigner!==t.isSigner?e.isSigner?-1:1:e.isWritable!==t.isWritable?e.isWritable?-1:1:e.pubkey.toBase58().localeCompare(t.pubkey.toBase58())}));const d=c.findIndex((e=>e.pubkey.equals(r)));if(d>-1){const[e]=c.splice(d,1);e.isSigner=!0,e.isWritable=!0,c.unshift(e)}else c.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const e of this.signatures){const t=c.findIndex((t=>t.pubkey.equals(e.publicKey)));if(!(t>-1))throw new Error(`unknown signer: ${e.publicKey.toString()}`);c[t].isSigner||(c[t].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let l=0,h=0,y=0;const m=[],O=[];c.forEach((({pubkey:e,isSigner:t,isWritable:r})=>{t?(m.push(e.toString()),l+=1,r||(h+=1)):(O.push(e.toString()),r||(y+=1))}));const k=m.concat(O),f=t.map((e=>{const{data:data,programId:t}=e;return{programIdIndex:k.indexOf(t.toString()),accounts:e.keys.map((meta=>k.indexOf(meta.pubkey.toString()))),data:j.a.encode(data)}}));return f.forEach((e=>{J(e.programIdIndex>=0),e.accounts.forEach((e=>J(e>=0)))})),new X({header:{numRequiredSignatures:l,numReadonlySignedAccounts:h,numReadonlyUnsignedAccounts:y},accountKeys:k,recentBlockhash:e,instructions:f})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===t.length){if(this.signatures.every(((e,r)=>t[r].equals(e.publicKey))))return e}return this.signatures=t.map((e=>({signature:null,publicKey:e}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const t=new Set;this.signatures=e.filter((e=>{const r=e.toString();return!t.has(r)&&(t.add(r),!0)})).map((e=>({signature:null,publicKey:e})))}sign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const e=n.publicKey.toString();t.has(e)||(t.add(e),r.push(n))}this.signatures=r.map((e=>({signature:null,publicKey:e.publicKey})));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const e=n.publicKey.toString();t.has(e)||(t.add(e),r.push(n))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach((e=>{const t=x(r,e.secretKey);this._addSignature(e.publicKey,B(t))}))}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){J(64===t.length);const r=this.signatures.findIndex((t=>e.equals(t.publicKey)));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=n.Buffer.from(t)}verifySignatures(){return this._verifySignatures(this.serializeMessage(),!0)}_verifySignatures(e,t){for(const{signature:r,publicKey:n}of this.signatures)if(null===r){if(t)return!1}else if(!W(r,e,n.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r&&!this._verifySignatures(n,t))throw new Error("Signature verification failed");return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];$(r,t.length);const o=r.length+64*t.length+e.length,c=n.Buffer.alloc(o);return J(t.length<256),n.Buffer.from(r).copy(c,0),t.forEach((({signature:e},t)=>{null!==e&&(J(64===e.length,"signature has invalid length"),n.Buffer.from(e).copy(c,r.length+64*t))})),e.copy(c,r.length+64*t.length),J(c.length<=_,`Transaction too large: ${c.length} > 1232`),c}get keys(){return J(1===this.instructions.length),this.instructions[0].keys.map((e=>e.pubkey))}get programId(){return J(1===this.instructions.length),this.instructions[0].programId}get data(){return J(1===this.instructions.length),this.instructions[0].data}static from(e){let t=[...e];const r=F(t);let o=[];for(let i=0;i<r;i++){const e=t.slice(0,64);t=t.slice(64),o.push(j.a.encode(n.Buffer.from(e)))}return ee.populate(X.from(t),o)}static populate(e,t=[]){const r=new ee;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach(((t,n)=>{const o={signature:t==j.a.encode(Y)?null:j.a.decode(t),publicKey:e.accountKeys[n]};r.signatures.push(o)})),e.instructions.forEach((t=>{const n=t.accounts.map((t=>{const n=e.accountKeys[t];return{pubkey:n,isSigner:r.signatures.some((e=>e.publicKey.toString()===n.toString()))||e.isAccountSigner(t),isWritable:e.isAccountWritable(t)}}));r.instructions.push(new Z({keys:n,programId:e.accountKeys[t.programIdIndex],data:j.a.decode(t.data)}))})),r._message=e,r._json=r.toJSON(),r}}const te=new L("SysvarC1ock11111111111111111111111111111111"),re=(new L("SysvarEpochSchedu1e111111111111111111111111"),new L("Sysvar1nstructions1111111111111111111111111"),new L("SysvarRecentB1ockHashes11111111111111111111")),ie=new L("SysvarRent111111111111111111111111111111111"),ne=(new L("SysvarRewards111111111111111111111111111111"),new L("SysvarS1otHashes111111111111111111111111111"),new L("SysvarS1otHistory11111111111111111111111111"),new L("SysvarStakeHistory1111111111111111111111111"));async function se(e,t,r,n){const o=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},c=await e.sendTransaction(t,r,o);let d;if(null!=t.recentBlockhash&&null!=t.lastValidBlockHeight)d=(await e.confirmTransaction({abortSignal:null==n?void 0:n.abortSignal,signature:c,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},n&&n.commitment)).value;else if(null!=t.minNonceContextSlot&&null!=t.nonceInfo){const{nonceInstruction:r}=t.nonceInfo,o=r.keys[0].pubkey;d=(await e.confirmTransaction({abortSignal:null==n?void 0:n.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:o,nonceValue:t.nonceInfo.nonce,signature:c},n&&n.commitment)).value}else null!=(null==n?void 0:n.abortSignal)&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),d=(await e.confirmTransaction(c,n&&n.commitment)).value;if(d.err)throw new Error(`Transaction ${c} failed (${JSON.stringify(d)})`);return c}function oe(e){return new Promise((t=>setTimeout(t,e)))}function ce(e,t){const r=e.layout.span>=0?e.layout.span:H(e,t),data=n.Buffer.alloc(r),o=Object.assign({instruction:e.index},t);return e.layout.encode(o,data),data}const ae=O.nu64("lamportsPerSignature"),ue=O.struct([O.u32("version"),O.u32("state"),U("authorizedPubkey"),U("nonce"),O.struct([ae],"feeCalculator")]),be=ue.span;const de=(le=8,e=>{const t=Object(O.blob)(le,e),{encode:r,decode:o}=(e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)}))(t),c=t;return c.decode=(e,t)=>{const r=o(e,t);return Object(k.toBigIntLE)(n.Buffer.from(r))},c.encode=(e,t,n)=>{const o=Object(k.toBufferLE)(e,le);return r(o,t,n)},c});var le;const he=Object.freeze({Create:{index:0,layout:O.struct([O.u32("instruction"),O.ns64("lamports"),O.ns64("space"),U("programId")])},Assign:{index:1,layout:O.struct([O.u32("instruction"),U("programId")])},Transfer:{index:2,layout:O.struct([O.u32("instruction"),de("lamports")])},CreateWithSeed:{index:3,layout:O.struct([O.u32("instruction"),U("base"),V("seed"),O.ns64("lamports"),O.ns64("space"),U("programId")])},AdvanceNonceAccount:{index:4,layout:O.struct([O.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:O.struct([O.u32("instruction"),O.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:O.struct([O.u32("instruction"),U("authorized")])},AuthorizeNonceAccount:{index:7,layout:O.struct([O.u32("instruction"),U("authorized")])},Allocate:{index:8,layout:O.struct([O.u32("instruction"),O.ns64("space")])},AllocateWithSeed:{index:9,layout:O.struct([O.u32("instruction"),U("base"),V("seed"),O.ns64("space"),U("programId")])},AssignWithSeed:{index:10,layout:O.struct([O.u32("instruction"),U("base"),V("seed"),U("programId")])},TransferWithSeed:{index:11,layout:O.struct([O.u32("instruction"),de("lamports"),V("seed"),U("programId")])},UpgradeNonceAccount:{index:12,layout:O.struct([O.u32("instruction")])}});class pe{constructor(){}static createAccount(e){const data=ce(he.Create,{lamports:e.lamports,space:e.space,programId:B(e.programId.toBuffer())});return new Z({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:data})}static transfer(e){let data,t;if("basePubkey"in e){data=ce(he.TransferWithSeed,{lamports:BigInt(e.lamports),seed:e.seed,programId:B(e.programId.toBuffer())}),t=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{data=ce(he.Transfer,{lamports:BigInt(e.lamports)}),t=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new Z({keys:t,programId:this.programId,data:data})}static assign(e){let data,t;if("basePubkey"in e){data=ce(he.AssignWithSeed,{base:B(e.basePubkey.toBuffer()),seed:e.seed,programId:B(e.programId.toBuffer())}),t=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{data=ce(he.Assign,{programId:B(e.programId.toBuffer())}),t=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Z({keys:t,programId:this.programId,data:data})}static createAccountWithSeed(e){const data=ce(he.CreateWithSeed,{base:B(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:B(e.programId.toBuffer())});let t=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&t.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new Z({keys:t,programId:this.programId,data:data})}static createNonceAccount(e){const t=new ee;"basePubkey"in e&&"seed"in e?t.add(pe.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:be,programId:this.programId})):t.add(pe.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:be,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const data=ce(he.InitializeNonceAccount,{authorized:B(e.authorizedPubkey.toBuffer())}),t={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:re,isSigner:!1,isWritable:!1},{pubkey:ie,isSigner:!1,isWritable:!1}],programId:this.programId,data:data};return new Z(t)}static nonceAdvance(e){const data=ce(he.AdvanceNonceAccount),t={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:re,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:data};return new Z(t)}static nonceWithdraw(e){const data=ce(he.WithdrawNonceAccount,{lamports:e.lamports});return new Z({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:re,isSigner:!1,isWritable:!1},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:data})}static nonceAuthorize(e){const data=ce(he.AuthorizeNonceAccount,{authorized:B(e.newAuthorizedPubkey.toBuffer())});return new Z({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:data})}static allocate(e){let data,t;if("basePubkey"in e){data=ce(he.AllocateWithSeed,{base:B(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:B(e.programId.toBuffer())}),t=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{data=ce(he.Allocate,{space:e.space}),t=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new Z({keys:t,programId:this.programId,data:data})}}pe.programId=new L("11111111111111111111111111111111");class je{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/je.chunkSize)+1+1)}static async load(e,t,r,o,data){{const n=await e.getMinimumBalanceForRentExemption(data.length),c=await e.getAccountInfo(r.publicKey,"confirmed");let d=null;if(null!==c){if(c.executable)return console.error("Program load failed, account is already executable"),!1;c.data.length!==data.length&&(d=d||new ee,d.add(pe.allocate({accountPubkey:r.publicKey,space:data.length}))),c.owner.equals(o)||(d=d||new ee,d.add(pe.assign({accountPubkey:r.publicKey,programId:o}))),c.lamports<n&&(d=d||new ee,d.add(pe.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:n-c.lamports})))}else d=(new ee).add(pe.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:n>0?n:1,space:data.length,programId:o}));null!==d&&await se(e,d,[t,r],{commitment:"confirmed"})}const c=O.struct([O.u32("instruction"),O.u32("offset"),O.u32("bytesLength"),O.u32("bytesLengthPadding"),O.seq(O.u8("byte"),O.offset(O.u32(),-8),"bytes")]),d=je.chunkSize;let l=0,h=data,j=[];for(;h.length>0;){const y=h.slice(0,d),data=n.Buffer.alloc(d+16);c.encode({instruction:0,offset:l,bytes:y,bytesLength:0,bytesLengthPadding:0},data);const m=(new ee).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:o,data:data});if(j.push(se(e,m,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await oe(1e3/e)}l+=d,h=h.slice(d)}await Promise.all(j);{const c=O.struct([O.u32("instruction")]),data=n.Buffer.alloc(c.span);c.encode({instruction:1},data);const d=(new ee).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1}],programId:o,data:data});await se(e,d,[t,r],{commitment:"confirmed"})}return!0}}je.chunkSize=932;new L("BPFLoader2111111111111111111111111111111111");Object.prototype.toString,Object.keys;class ge extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}class ye extends Error{constructor({code:code,message:e,data:data},t){super(null!=t?`${t}: ${e}`:e),this.code=void 0,this.data=void 0,this.code=code,this.data=data,this.name="SolanaJSONRPCError"}}globalThis.fetch;O.struct([O.u32("typeIndex"),de("deactivationSlot"),O.nu64("lastExtendedSlot"),O.u8("lastExtendedStartIndex"),O.u8(),O.seq(U(),O.offset(O.u8(),-1),"authority")]);var me;const Oe=Object(f.e)(Object(f.g)(L),Object(f.m)(),(e=>new L(e))),ke=Object(f.n)([Object(f.m)(),Object(f.h)("base64")]),fe=Object(f.e)(Object(f.g)(n.Buffer),ke,(e=>n.Buffer.from(e[0],"base64")));function Se(e){return Object(f.p)([Object(f.o)({jsonrpc:Object(f.h)("2.0"),id:Object(f.m)(),result:e}),Object(f.o)({jsonrpc:Object(f.h)("2.0"),id:Object(f.m)(),error:Object(f.o)({code:Object(f.q)(),message:Object(f.m)(),data:Object(f.k)(Object(f.a)())})})])}const Ie=Se(Object(f.q)());function we(e){return Object(f.e)(Se(e),Ie,(t=>"error"in t?t:{...t,result:Object(f.f)(t.result,e)}))}function Pe(e){return we(Object(f.o)({context:Object(f.o)({slot:Object(f.j)()}),value:e}))}function ve(e){return Object(f.o)({context:Object(f.o)({slot:Object(f.j)()}),value:e})}const Ae=Object(f.o)({foundation:Object(f.j)(),foundationTerm:Object(f.j)(),initial:Object(f.j)(),taper:Object(f.j)(),terminal:Object(f.j)()}),xe=(we(Object(f.b)(Object(f.i)(Object(f.o)({epoch:Object(f.j)(),effectiveSlot:Object(f.j)(),amount:Object(f.j)(),postBalance:Object(f.j)()})))),Object(f.o)({epoch:Object(f.j)(),slotIndex:Object(f.j)(),slotsInEpoch:Object(f.j)(),absoluteSlot:Object(f.j)(),blockHeight:Object(f.k)(Object(f.j)()),transactionCount:Object(f.k)(Object(f.j)())})),We=Object(f.o)({slotsPerEpoch:Object(f.j)(),leaderScheduleSlotOffset:Object(f.j)(),warmup:Object(f.d)(),firstNormalEpoch:Object(f.j)(),firstNormalSlot:Object(f.j)()}),Be=Object(f.l)(Object(f.m)(),Object(f.b)(Object(f.j)())),ze=Object(f.i)(Object(f.p)([Object(f.o)({}),Object(f.m)()])),Ke=Object(f.o)({err:ze}),Ee=Object(f.h)("receivedSignature");Object(f.o)({"solana-core":Object(f.m)(),"feature-set":Object(f.k)(Object(f.j)())}),Pe(Object(f.o)({err:Object(f.i)(Object(f.p)([Object(f.o)({}),Object(f.m)()])),logs:Object(f.i)(Object(f.b)(Object(f.m)())),accounts:Object(f.k)(Object(f.i)(Object(f.b)(Object(f.i)(Object(f.o)({executable:Object(f.d)(),owner:Object(f.m)(),lamports:Object(f.j)(),data:Object(f.b)(Object(f.m)()),rentEpoch:Object(f.k)(Object(f.j)())}))))),unitsConsumed:Object(f.k)(Object(f.j)()),returnData:Object(f.k)(Object(f.i)(Object(f.o)({programId:Object(f.m)(),data:Object(f.n)([Object(f.m)(),Object(f.h)("base64")])})))})),Pe(Object(f.o)({byIdentity:Object(f.l)(Object(f.m)(),Object(f.b)(Object(f.j)())),range:Object(f.o)({firstSlot:Object(f.j)(),lastSlot:Object(f.j)()})}));we(Ae),we(xe),we(We),we(Be),we(Object(f.j)()),Pe(Object(f.o)({total:Object(f.j)(),circulating:Object(f.j)(),nonCirculating:Object(f.j)(),nonCirculatingAccounts:Object(f.b)(Oe)}));const Te=Object(f.o)({amount:Object(f.m)(),uiAmount:Object(f.i)(Object(f.j)()),decimals:Object(f.j)(),uiAmountString:Object(f.k)(Object(f.m)())}),Ce=(Pe(Object(f.b)(Object(f.o)({address:Oe,amount:Object(f.m)(),uiAmount:Object(f.i)(Object(f.j)()),decimals:Object(f.j)(),uiAmountString:Object(f.k)(Object(f.m)())}))),Pe(Object(f.b)(Object(f.o)({pubkey:Oe,account:Object(f.o)({executable:Object(f.d)(),owner:Oe,lamports:Object(f.j)(),data:fe,rentEpoch:Object(f.j)()})}))),Object(f.o)({program:Object(f.m)(),parsed:Object(f.q)(),space:Object(f.j)()})),Le=(Pe(Object(f.b)(Object(f.o)({pubkey:Oe,account:Object(f.o)({executable:Object(f.d)(),owner:Oe,lamports:Object(f.j)(),data:Ce,rentEpoch:Object(f.j)()})}))),Pe(Object(f.b)(Object(f.o)({lamports:Object(f.j)(),address:Oe}))),Object(f.o)({executable:Object(f.d)(),owner:Oe,lamports:Object(f.j)(),data:fe,rentEpoch:Object(f.j)()})),qe=(Object(f.o)({pubkey:Oe,account:Le}),Object(f.e)(Object(f.p)([Object(f.g)(n.Buffer),Ce]),Object(f.p)([ke,Ce]),(e=>Array.isArray(e)?Object(f.f)(e,fe):e))),_e=Object(f.o)({executable:Object(f.d)(),owner:Oe,lamports:Object(f.j)(),data:qe,rentEpoch:Object(f.j)()}),Ne=(Object(f.o)({pubkey:Oe,account:_e}),Object(f.o)({state:Object(f.p)([Object(f.h)("active"),Object(f.h)("inactive"),Object(f.h)("activating"),Object(f.h)("deactivating")]),active:Object(f.j)(),inactive:Object(f.j)()}),we(Object(f.b)(Object(f.o)({signature:Object(f.m)(),slot:Object(f.j)(),err:ze,memo:Object(f.i)(Object(f.m)()),blockTime:Object(f.k)(Object(f.i)(Object(f.j)()))}))),we(Object(f.b)(Object(f.o)({signature:Object(f.m)(),slot:Object(f.j)(),err:ze,memo:Object(f.i)(Object(f.m)()),blockTime:Object(f.k)(Object(f.i)(Object(f.j)()))}))),Object(f.o)({subscription:Object(f.j)(),result:ve(Le)}),Object(f.o)({pubkey:Oe,account:Le})),Re=(Object(f.o)({subscription:Object(f.j)(),result:ve(Ne)}),Object(f.o)({parent:Object(f.j)(),slot:Object(f.j)(),root:Object(f.j)()})),Me=(Object(f.o)({subscription:Object(f.j)(),result:Re}),Object(f.p)([Object(f.o)({type:Object(f.p)([Object(f.h)("firstShredReceived"),Object(f.h)("completed"),Object(f.h)("optimisticConfirmation"),Object(f.h)("root")]),slot:Object(f.j)(),timestamp:Object(f.j)()}),Object(f.o)({type:Object(f.h)("createdBank"),parent:Object(f.j)(),slot:Object(f.j)(),timestamp:Object(f.j)()}),Object(f.o)({type:Object(f.h)("frozen"),slot:Object(f.j)(),timestamp:Object(f.j)(),stats:Object(f.o)({numTransactionEntries:Object(f.j)(),numSuccessfulTransactions:Object(f.j)(),numFailedTransactions:Object(f.j)(),maxTransactionsPerEntry:Object(f.j)()})}),Object(f.o)({type:Object(f.h)("dead"),slot:Object(f.j)(),timestamp:Object(f.j)(),err:Object(f.m)()})])),De=(Object(f.o)({subscription:Object(f.j)(),result:Me}),Object(f.o)({subscription:Object(f.j)(),result:ve(Object(f.p)([Ke,Ee]))}),Object(f.o)({subscription:Object(f.j)(),result:Object(f.j)()}),Object(f.o)({pubkey:Object(f.m)(),gossip:Object(f.i)(Object(f.m)()),tpu:Object(f.i)(Object(f.m)()),rpc:Object(f.i)(Object(f.m)()),version:Object(f.i)(Object(f.m)())}),Object(f.o)({votePubkey:Object(f.m)(),nodePubkey:Object(f.m)(),activatedStake:Object(f.j)(),epochVoteAccount:Object(f.d)(),epochCredits:Object(f.b)(Object(f.n)([Object(f.j)(),Object(f.j)(),Object(f.j)()])),commission:Object(f.j)(),lastVote:Object(f.j)(),rootSlot:Object(f.i)(Object(f.j)())})),Ue=(we(Object(f.o)({current:Object(f.b)(De),delinquent:Object(f.b)(De)})),Object(f.p)([Object(f.h)("processed"),Object(f.h)("confirmed"),Object(f.h)("finalized")])),Ve=Object(f.o)({slot:Object(f.j)(),confirmations:Object(f.i)(Object(f.j)()),err:ze,confirmationStatus:Object(f.k)(Ue)}),He=(Pe(Object(f.b)(Object(f.i)(Ve))),we(Object(f.j)()),Object(f.o)({accountKey:Oe,writableIndexes:Object(f.b)(Object(f.j)()),readonlyIndexes:Object(f.b)(Object(f.j)())})),Fe=Object(f.o)({signatures:Object(f.b)(Object(f.m)()),message:Object(f.o)({accountKeys:Object(f.b)(Object(f.m)()),header:Object(f.o)({numRequiredSignatures:Object(f.j)(),numReadonlySignedAccounts:Object(f.j)(),numReadonlyUnsignedAccounts:Object(f.j)()}),instructions:Object(f.b)(Object(f.o)({accounts:Object(f.b)(Object(f.j)()),data:Object(f.m)(),programIdIndex:Object(f.j)()})),recentBlockhash:Object(f.m)(),addressTableLookups:Object(f.k)(Object(f.b)(He))})}),$e=Object(f.o)({pubkey:Oe,signer:Object(f.d)(),writable:Object(f.d)(),source:Object(f.k)(Object(f.p)([Object(f.h)("transaction"),Object(f.h)("lookupTable")]))}),Je=Object(f.o)({accountKeys:Object(f.b)($e),signatures:Object(f.b)(Object(f.m)())}),Ge=Object(f.o)({parsed:Object(f.q)(),program:Object(f.m)(),programId:Oe}),Xe=Object(f.o)({accounts:Object(f.b)(Oe),data:Object(f.m)(),programId:Oe}),Qe=Object(f.p)([Xe,Ge]),Ye=Object(f.p)([Object(f.o)({parsed:Object(f.q)(),program:Object(f.m)(),programId:Object(f.m)()}),Object(f.o)({accounts:Object(f.b)(Object(f.m)()),data:Object(f.m)(),programId:Object(f.m)()})]),Ze=Object(f.e)(Qe,Ye,(e=>"accounts"in e?Object(f.f)(e,Xe):Object(f.f)(e,Ge))),et=Object(f.o)({signatures:Object(f.b)(Object(f.m)()),message:Object(f.o)({accountKeys:Object(f.b)($e),instructions:Object(f.b)(Ze),recentBlockhash:Object(f.m)(),addressTableLookups:Object(f.k)(Object(f.i)(Object(f.b)(He)))})}),tt=Object(f.o)({accountIndex:Object(f.j)(),mint:Object(f.m)(),owner:Object(f.k)(Object(f.m)()),uiTokenAmount:Te}),it=Object(f.o)({writable:Object(f.b)(Oe),readonly:Object(f.b)(Oe)}),nt=Object(f.o)({err:ze,fee:Object(f.j)(),innerInstructions:Object(f.k)(Object(f.i)(Object(f.b)(Object(f.o)({index:Object(f.j)(),instructions:Object(f.b)(Object(f.o)({accounts:Object(f.b)(Object(f.j)()),data:Object(f.m)(),programIdIndex:Object(f.j)()}))})))),preBalances:Object(f.b)(Object(f.j)()),postBalances:Object(f.b)(Object(f.j)()),logMessages:Object(f.k)(Object(f.i)(Object(f.b)(Object(f.m)()))),preTokenBalances:Object(f.k)(Object(f.i)(Object(f.b)(tt))),postTokenBalances:Object(f.k)(Object(f.i)(Object(f.b)(tt))),loadedAddresses:Object(f.k)(it),computeUnitsConsumed:Object(f.k)(Object(f.j)())}),st=Object(f.o)({err:ze,fee:Object(f.j)(),innerInstructions:Object(f.k)(Object(f.i)(Object(f.b)(Object(f.o)({index:Object(f.j)(),instructions:Object(f.b)(Ze)})))),preBalances:Object(f.b)(Object(f.j)()),postBalances:Object(f.b)(Object(f.j)()),logMessages:Object(f.k)(Object(f.i)(Object(f.b)(Object(f.m)()))),preTokenBalances:Object(f.k)(Object(f.i)(Object(f.b)(tt))),postTokenBalances:Object(f.k)(Object(f.i)(Object(f.b)(tt))),loadedAddresses:Object(f.k)(it),computeUnitsConsumed:Object(f.k)(Object(f.j)())}),ot=Object(f.p)([Object(f.h)(0),Object(f.h)("legacy")]),ct=Object(f.o)({pubkey:Object(f.m)(),lamports:Object(f.j)(),postBalance:Object(f.i)(Object(f.j)()),rewardType:Object(f.i)(Object(f.m)())}),at=(we(Object(f.i)(Object(f.o)({blockhash:Object(f.m)(),previousBlockhash:Object(f.m)(),parentSlot:Object(f.j)(),transactions:Object(f.b)(Object(f.o)({transaction:Fe,meta:Object(f.i)(nt),version:Object(f.k)(ot)})),rewards:Object(f.k)(Object(f.b)(ct)),blockTime:Object(f.i)(Object(f.j)()),blockHeight:Object(f.i)(Object(f.j)())}))),we(Object(f.i)(Object(f.o)({blockhash:Object(f.m)(),previousBlockhash:Object(f.m)(),parentSlot:Object(f.j)(),rewards:Object(f.k)(Object(f.b)(ct)),blockTime:Object(f.i)(Object(f.j)()),blockHeight:Object(f.i)(Object(f.j)())}))),we(Object(f.i)(Object(f.o)({blockhash:Object(f.m)(),previousBlockhash:Object(f.m)(),parentSlot:Object(f.j)(),transactions:Object(f.b)(Object(f.o)({transaction:Je,meta:Object(f.i)(nt),version:Object(f.k)(ot)})),rewards:Object(f.k)(Object(f.b)(ct)),blockTime:Object(f.i)(Object(f.j)()),blockHeight:Object(f.i)(Object(f.j)())}))),we(Object(f.i)(Object(f.o)({blockhash:Object(f.m)(),previousBlockhash:Object(f.m)(),parentSlot:Object(f.j)(),transactions:Object(f.b)(Object(f.o)({transaction:et,meta:Object(f.i)(st),version:Object(f.k)(ot)})),rewards:Object(f.k)(Object(f.b)(ct)),blockTime:Object(f.i)(Object(f.j)()),blockHeight:Object(f.i)(Object(f.j)())}))),we(Object(f.i)(Object(f.o)({blockhash:Object(f.m)(),previousBlockhash:Object(f.m)(),parentSlot:Object(f.j)(),transactions:Object(f.b)(Object(f.o)({transaction:Je,meta:Object(f.i)(st),version:Object(f.k)(ot)})),rewards:Object(f.k)(Object(f.b)(ct)),blockTime:Object(f.i)(Object(f.j)()),blockHeight:Object(f.i)(Object(f.j)())}))),we(Object(f.i)(Object(f.o)({blockhash:Object(f.m)(),previousBlockhash:Object(f.m)(),parentSlot:Object(f.j)(),rewards:Object(f.k)(Object(f.b)(ct)),blockTime:Object(f.i)(Object(f.j)()),blockHeight:Object(f.i)(Object(f.j)())}))),we(Object(f.i)(Object(f.o)({blockhash:Object(f.m)(),previousBlockhash:Object(f.m)(),parentSlot:Object(f.j)(),transactions:Object(f.b)(Object(f.o)({transaction:Fe,meta:Object(f.i)(nt)})),rewards:Object(f.k)(Object(f.b)(ct)),blockTime:Object(f.i)(Object(f.j)())}))),we(Object(f.i)(Object(f.o)({blockhash:Object(f.m)(),previousBlockhash:Object(f.m)(),parentSlot:Object(f.j)(),signatures:Object(f.b)(Object(f.m)()),blockTime:Object(f.i)(Object(f.j)())}))),we(Object(f.i)(Object(f.o)({slot:Object(f.j)(),meta:nt,blockTime:Object(f.k)(Object(f.i)(Object(f.j)())),transaction:Fe,version:Object(f.k)(ot)}))),we(Object(f.i)(Object(f.o)({slot:Object(f.j)(),transaction:et,meta:Object(f.i)(st),blockTime:Object(f.k)(Object(f.i)(Object(f.j)())),version:Object(f.k)(ot)}))),Pe(Object(f.o)({blockhash:Object(f.m)(),feeCalculator:Object(f.o)({lamportsPerSignature:Object(f.j)()})})),Pe(Object(f.o)({blockhash:Object(f.m)(),lastValidBlockHeight:Object(f.j)()})),Object(f.o)({slot:Object(f.j)(),numTransactions:Object(f.j)(),numSlots:Object(f.j)(),samplePeriodSecs:Object(f.j)()})),ut=(we(Object(f.b)(at)),Pe(Object(f.i)(Object(f.o)({feeCalculator:Object(f.o)({lamportsPerSignature:Object(f.j)()})}))),we(Object(f.m)()),we(Object(f.m)()),Object(f.o)({err:ze,logs:Object(f.b)(Object(f.m)()),signature:Object(f.m)()}));Object(f.o)({result:ve(ut),subscription:Object(f.j)()}),me="0.0.0-development";class bt{constructor(e){this._keypair=void 0,this._keypair=null!=e?e:P()}static generate(){return new bt(P())}static fromSecretKey(e,t){if(64!==e.byteLength)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const t=e.slice(0,32),n=v(t);for(let e=0;e<32;e++)if(r[e]!==n[e])throw new Error("provided secretKey is invalid")}return new bt({publicKey:r,secretKey:e})}static fromSeed(e){const t=v(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new bt({publicKey:t,secretKey:r})}get publicKey(){return new L(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const lt=Object.freeze({CreateLookupTable:{index:0,layout:O.struct([O.u32("instruction"),de("recentSlot"),O.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:O.struct([O.u32("instruction")])},ExtendLookupTable:{index:2,layout:O.struct([O.u32("instruction"),de(),O.seq(U(),O.offset(O.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:O.struct([O.u32("instruction")])},CloseLookupTable:{index:4,layout:O.struct([O.u32("instruction")])}});class ht{constructor(){}static createLookupTable(e){const[t,r]=L.findProgramAddressSync([e.authority.toBuffer(),Object(k.toBufferLE)(BigInt(e.recentSlot),8)],this.programId),data=ce(lt.CreateLookupTable,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),n=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:pe.programId,isSigner:!1,isWritable:!1}];return[new Z({programId:this.programId,keys:n,data:data}),t]}static freezeLookupTable(e){const data=ce(lt.FreezeLookupTable),t=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new Z({programId:this.programId,keys:t,data:data})}static extendLookupTable(e){const data=ce(lt.ExtendLookupTable,{addresses:e.addresses.map((e=>e.toBytes()))}),t=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&t.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:pe.programId,isSigner:!1,isWritable:!1}),new Z({programId:this.programId,keys:t,data:data})}static deactivateLookupTable(e){const data=ce(lt.DeactivateLookupTable),t=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new Z({programId:this.programId,keys:t,data:data})}static closeLookupTable(e){const data=ce(lt.CloseLookupTable),t=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new Z({programId:this.programId,keys:t,data:data})}}ht.programId=new L("AddressLookupTab1e1111111111111111111111111");const pt=Object.freeze({RequestUnits:{index:0,layout:O.struct([O.u8("instruction"),O.u32("units"),O.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:O.struct([O.u8("instruction"),O.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:O.struct([O.u8("instruction"),O.u32("units")])},SetComputeUnitPrice:{index:3,layout:O.struct([O.u8("instruction"),de("microLamports")])}});class jt{constructor(){}static requestUnits(e){const data=ce(pt.RequestUnits,e);return new Z({keys:[],programId:this.programId,data:data})}static requestHeapFrame(e){const data=ce(pt.RequestHeapFrame,e);return new Z({keys:[],programId:this.programId,data:data})}static setComputeUnitLimit(e){const data=ce(pt.SetComputeUnitLimit,e);return new Z({keys:[],programId:this.programId,data:data})}static setComputeUnitPrice(e){const data=ce(pt.SetComputeUnitPrice,{microLamports:BigInt(e.microLamports)});return new Z({keys:[],programId:this.programId,data:data})}}jt.programId=new L("ComputeBudget111111111111111111111111111111");const gt=O.struct([O.u8("numSignatures"),O.u8("padding"),O.u16("signatureOffset"),O.u16("signatureInstructionIndex"),O.u16("publicKeyOffset"),O.u16("publicKeyInstructionIndex"),O.u16("messageDataOffset"),O.u16("messageDataSize"),O.u16("messageInstructionIndex")]);class yt{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:o,instructionIndex:c}=e;J(32===t.length,`Public Key must be 32 bytes but received ${t.length} bytes`),J(64===o.length,`Signature must be 64 bytes but received ${o.length} bytes`);const d=gt.span,l=d+t.length,h=l+o.length,j=n.Buffer.alloc(h+r.length),y=null==c?65535:c;return gt.encode({numSignatures:1,padding:0,signatureOffset:l,signatureInstructionIndex:y,publicKeyOffset:d,publicKeyInstructionIndex:y,messageDataOffset:h,messageDataSize:r.length,messageInstructionIndex:y},j),j.fill(t,d),j.fill(o,l),j.fill(r,h),new Z({keys:[],programId:yt.programId,data:j})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;J(64===t.length,`Private key must be 64 bytes but received ${t.length} bytes`);try{const e=bt.fromSecretKey(t),o=e.publicKey.toBytes(),c=x(r,e.secretKey);return this.createInstructionWithPublicKey({publicKey:o,message:r,signature:c,instructionIndex:n})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}yt.programId=new L("Ed25519SigVerify111111111111111111111111111"),w.c.hmacSha256Sync=(e,...t)=>{const r=I.hmac.create(y.sha256,e);return t.forEach((e=>r.update(e))),r.digest()};w.c.isValidPrivateKey;const mt=w.a,Ot=O.struct([O.u8("numSignatures"),O.u16("signatureOffset"),O.u8("signatureInstructionIndex"),O.u16("ethAddressOffset"),O.u8("ethAddressInstructionIndex"),O.u16("messageDataOffset"),O.u16("messageDataSize"),O.u8("messageInstructionIndex"),O.blob(20,"ethAddress"),O.blob(64,"signature"),O.u8("recoveryId")]);class kt{constructor(){}static publicKeyToEthAddress(e){J(64===e.length,`Public key must be 64 bytes but received ${e.length} bytes`);try{return n.Buffer.from(Object(S.keccak_256)(B(e))).slice(-20)}catch(e){throw new Error(`Error constructing Ethereum address: ${e}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:o,instructionIndex:c}=e;return kt.createInstructionWithEthAddress({ethAddress:kt.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:o,instructionIndex:c})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:o,recoveryId:c,instructionIndex:d=0}=e;let l;l="string"==typeof t?t.startsWith("0x")?n.Buffer.from(t.substr(2),"hex"):n.Buffer.from(t,"hex"):t,J(20===l.length,`Address must be 20 bytes but received ${l.length} bytes`);const h=12+l.length,j=h+o.length+1,y=n.Buffer.alloc(Ot.span+r.length);return Ot.encode({numSignatures:1,signatureOffset:h,signatureInstructionIndex:d,ethAddressOffset:12,ethAddressInstructionIndex:d,messageDataOffset:j,messageDataSize:r.length,messageInstructionIndex:d,signature:B(o),ethAddress:B(l),recoveryId:c},y),y.fill(B(r),Ot.span),new Z({keys:[],programId:kt.programId,data:y})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:o}=e;J(32===t.length,`Private key must be 32 bytes but received ${t.length} bytes`);try{const e=B(t),l=mt(e,!1).slice(1),h=n.Buffer.from(Object(S.keccak_256)(B(r))),[j,y]=(c=h,d=e,w.b(c,d,{der:!1,recovered:!0}));return this.createInstructionWithPublicKey({publicKey:l,message:r,signature:j,recoveryId:y,instructionIndex:o})}catch(e){throw new Error(`Error creating instruction; ${e}`)}var c,d}}kt.programId=new L("KeccakSecp256k11111111111111111111111111111");const ft=new L("StakeConfig11111111111111111111111111111111");class St{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}St.default=new St(0,0,L.default);const It=Object.freeze({Initialize:{index:0,layout:O.struct([O.u32("instruction"),((e="authorized")=>O.struct([U("staker"),U("withdrawer")],e))(),((e="lockup")=>O.struct([O.ns64("unixTimestamp"),O.ns64("epoch"),U("custodian")],e))()])},Authorize:{index:1,layout:O.struct([O.u32("instruction"),U("newAuthorized"),O.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:O.struct([O.u32("instruction")])},Split:{index:3,layout:O.struct([O.u32("instruction"),O.ns64("lamports")])},Withdraw:{index:4,layout:O.struct([O.u32("instruction"),O.ns64("lamports")])},Deactivate:{index:5,layout:O.struct([O.u32("instruction")])},Merge:{index:7,layout:O.struct([O.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:O.struct([O.u32("instruction"),U("newAuthorized"),O.u32("stakeAuthorizationType"),V("authoritySeed"),U("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class wt{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,o=n||St.default,data=ce(It.Initialize,{authorized:{staker:B(r.staker.toBuffer()),withdrawer:B(r.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:B(o.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1}],programId:this.programId,data:data};return new Z(c)}static createAccountWithSeed(e){const t=new ee;t.add(pe.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:o}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:o}))}static createAccount(e){const t=new ee;t.add(pe.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:o}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:o}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,data=ce(It.Delegate);return(new ee).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:ne,isSigner:!1,isWritable:!1},{pubkey:ft,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:data})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:o,custodianPubkey:c}=e,data=ce(It.Authorize,{newAuthorized:B(n.toBuffer()),stakeAuthorizationType:o.index}),d=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return c&&d.push({pubkey:c,isSigner:!1,isWritable:!1}),(new ee).add({keys:d,programId:this.programId,data:data})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:o,newAuthorizedPubkey:c,stakeAuthorizationType:d,custodianPubkey:l}=e,data=ce(It.AuthorizeWithSeed,{newAuthorized:B(c.toBuffer()),stakeAuthorizationType:d.index,authoritySeed:n,authorityOwner:B(o.toBuffer())}),h=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1}];return l&&h.push({pubkey:l,isSigner:!1,isWritable:!1}),(new ee).add({keys:h,programId:this.programId,data:data})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:o}=e,data=ce(It.Split,{lamports:o});return new Z({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:data})}static split(e){const t=new ee;return t.add(pe.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:0,space:this.space,programId:this.programId})),t.add(this.splitInstruction(e))}static splitWithSeed(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,basePubkey:o,seed:c,lamports:d}=e,l=new ee;return l.add(pe.allocate({accountPubkey:n,basePubkey:o,seed:c,space:this.space,programId:this.programId})),l.add(this.splitInstruction({stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:d}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,data=ce(It.Merge);return(new ee).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:ne,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:data})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:o,custodianPubkey:c}=e,data=ce(It.Withdraw,{lamports:o}),d=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:ne,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return c&&d.push({pubkey:c,isSigner:!1,isWritable:!1}),(new ee).add({keys:d,programId:this.programId,data:data})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,data=ce(It.Deactivate);return(new ee).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:data})}}wt.programId=new L("Stake11111111111111111111111111111111111111"),wt.space=200;const Pt=Object.freeze({InitializeAccount:{index:0,layout:O.struct([O.u32("instruction"),((e="voteInit")=>O.struct([U("nodePubkey"),U("authorizedVoter"),U("authorizedWithdrawer"),O.u8("commission")],e))()])},Authorize:{index:1,layout:O.struct([O.u32("instruction"),U("newAuthorized"),O.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:O.struct([O.u32("instruction"),O.ns64("lamports")])},AuthorizeWithSeed:{index:10,layout:O.struct([O.u32("instruction"),((e="voteAuthorizeWithSeedArgs")=>O.struct([O.u32("voteAuthorizationType"),U("currentAuthorityDerivedKeyOwnerPubkey"),V("currentAuthorityDerivedKeySeed"),U("newAuthorized")],e))()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class vt{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,data=ce(Pt.InitializeAccount,{voteInit:{nodePubkey:B(n.nodePubkey.toBuffer()),authorizedVoter:B(n.authorizedVoter.toBuffer()),authorizedWithdrawer:B(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),o={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:ie,isSigner:!1,isWritable:!1},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:data};return new Z(o)}static createAccount(e){const t=new ee;return t.add(pe.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:o}=e,data=ce(Pt.Authorize,{newAuthorized:B(n.toBuffer()),voteAuthorizationType:o.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ee).add({keys:c,programId:this.programId,data:data})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:o,voteAuthorizationType:c,votePubkey:d}=e,data=ce(Pt.AuthorizeWithSeed,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:B(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:B(o.toBuffer()),voteAuthorizationType:c.index}}),l=[{pubkey:d,isSigner:!1,isWritable:!0},{pubkey:te,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return(new ee).add({keys:l,programId:this.programId,data:data})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:o}=e,data=ce(Pt.Withdraw,{lamports:n}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return(new ee).add({keys:c,programId:this.programId,data:data})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insuffcient funds.");return vt.withdraw(e)}}vt.programId=new L("Vote111111111111111111111111111111111111111"),vt.space=3731;new L("Va1idator1nfo111111111111111111111111111111"),Object(f.o)({name:Object(f.m)(),website:Object(f.k)(Object(f.m)()),details:Object(f.k)(Object(f.m)()),keybaseUsername:Object(f.k)(Object(f.m)())});new L("Vote111111111111111111111111111111111111111"),O.struct([U("nodePubkey"),U("authorizedWithdrawer"),O.u8("commission"),O.nu64(),O.seq(O.struct([O.nu64("slot"),O.u32("confirmationCount")]),O.offset(O.u32(),-8),"votes"),O.u8("rootSlotValid"),O.nu64("rootSlot"),O.nu64(),O.seq(O.struct([O.nu64("epoch"),U("authorizedVoter")]),O.offset(O.u32(),-8),"authorizedVoters"),O.struct([O.seq(O.struct([U("authorizedPubkey"),O.nu64("epochOfLastAuthorizedSwitch"),O.nu64("targetEpoch")]),32,"buf"),O.nu64("idx"),O.u8("isEmpty")],"priorVoters"),O.nu64(),O.seq(O.struct([O.nu64("epoch"),O.nu64("credits"),O.nu64("prevCredits")]),O.offset(O.u32(),-8),"epochCredits"),O.struct([O.nu64("slot"),O.nu64("timestamp")],"lastTimestamp")])}}]);